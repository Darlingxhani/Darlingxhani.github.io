[{"title":"PE文件学习","url":"/2024/10/30/PE文件学习/","content":"\n## PE 文件的学习：\n\n### 1.了解\n\nPE（ Portable Execute）文件是Windows下可执行文件的总称，常见的有 **DLL，EXE，OCX，SYS** 等。它是微软在 UNIX 平台的 COFF（通用对象文件格式）基础上制作而成。**最初设计用来提高程序在不同操作系统上的移植性，但实际上这种文件格式仅用在 Windows 系列操作系统下**。**PE文件是指 32 位可执行文件，也称为PE32。64位的可执行文件称为 PE+ 或 PE32+，是PE(PE32)的一种扩展形式（请注意不是PE64)**。\n\n事实上，**一个文件是否是 PE 文件与其扩展名无关**，PE文件可以是任何扩展名。那 Windows 是怎么区分可执行文件和非可执行文件的呢？我们调用 LoadLibrary 传递了一个文件名，**系统是如何判断这个文件是一个合法的动态库呢？这就涉及到PE文件结构了。**\n\n![](PE文件学习/2.png)\n\n### 2.结构学习\n\n### 一、DOS头\n\nDOS头 的作用是兼容 MS-DOS 操作系统中的可执行文件，对于 32位PE文件来说，DOS 所起的作用就是显示一行文字，提示用户：我需要在32位windows上才可以运行。我认为这是个善意的玩笑，因为他并不像显示的那样不能运行，其实已经运行了，只是在 DOS 上没有干用户希望看到的工作而已，好吧，我承认这不是重点。但是，至少我们看一下这个头是如何定义的：\n\n```c\ntypedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header\n    WORD   e_magic;                     // Magic number\n    WORD   e_cblp;                      // Bytes on last page of file\n    WORD   e_cp;                        // Pages in file\n    WORD   e_crlc;                      // Relocations\n    WORD   e_cparhdr;                   // Size of header in paragraphs\n    WORD   e_minalloc;                  // Minimum extra paragraphs needed\n    WORD   e_maxalloc;                  // Maximum extra paragraphs needed\n    WORD   e_ss;                        // Initial (relative) SS value\n    WORD   e_sp;                        // Initial SP value\n    WORD   e_csum;                      // Checksum\n    WORD   e_ip;                        // Initial IP value\n    WORD   e_cs;                        // Initial (relative) CS value\n    WORD   e_lfarlc;                    // File address of relocation table\n    WORD   e_ovno;                      // Overlay number\n    WORD   e_res[4];                    // Reserved words\n    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)\n    WORD   e_oeminfo;                   // OEM information; e_oemid specific\n    WORD   e_res2[10];                  // Reserved words\n    LONG   e_lfanew;                    // File address of new exe header\n  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;\n```\n\n![](PE文件学习/1.png)\n\n### 二、NT头\n\n顺着 DOS 头中的 **e_lfanew**，我们很容易可以找到 **NT头，这个才是 32位PE文件中最有用的头**，定义如下:\n\n```C\ntypedef struct _IMAGE_NT_HEADERS {\n    DWORD Signature;\n    IMAGE_FILE_HEADER FileHeader;\n    IMAGE_OPTIONAL_HEADER32 OptionalHeader;\n} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;\n```\n\n##### 1.Signature\n\n类似于 DOS头中的 e_magic，其高16位是0，低16是0x4550，用字符表示是 'PE‘ 。⭐⭐⭐\n\n##### 2.IMAGE_FILE_HEADER(文件头)\n\n```c\ntypedef struct _IMAGE_FILE_HEADER {\n    WORD    Machine;\n    WORD    NumberOfSections;⭐⭐⭐\n    DWORD   TimeDateStamp;\n    DWORD   PointerToSymbolTable;\n    DWORD   NumberOfSymbols;\n    WORD    SizeOfOptionalHeader;\n    WORD    Characteristics;\n} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;\n```\n\nMachine：该文件的运行平台，是 x86、x64 还是 I64 等等；\n\n<u>NumberOfSections：   该PE文件中有多少个节，也就是节表中的项数。</u>\nTimeDateStamp：      PE文件的创建时间，一般有连接器填写。\nPointerToSymbolTable： COFF文件符号表在文件中的偏移。\nNumberOfSymbols：    符号表的数量。\nSizeOfOptionalHeader： 紧随其后的可选头的大小。\nCharacteristics：       可执行文件的属性\n\n##### 3.IMAGE_OPTIONAL_HEADER(可选头)\n\n***别看他名字叫可选头，其实一点都不能少，不过，它在不同的平台下是不一样的，例如32位下是IMAGE_OPTIONAL_HEADER32，而在64位下是IMAGE_OPTIONAL_HEADER64。为了简单起见，我们只看32位。***\n\n```C\ntypedef struct _IMAGE_OPTIONAL_HEADER {\n    WORD    Magic;\n    BYTE    MajorLinkerVersion;\n    BYTE    MinorLinkerVersion;\n    DWORD   SizeOfCode;\n    DWORD   SizeOfInitializedData;\n    DWORD   SizeOfUninitializedData;\n    DWORD   AddressOfEntryPoint;\n    DWORD   BaseOfCode;\n    DWORD   BaseOfData;\n    DWORD   ImageBase;\n    DWORD   SectionAlignment;  ⭐⭐⭐\n    DWORD   FileAlignment;  ⭐⭐⭐\n    WORD    MajorOperatingSystemVersion;\n    WORD    MinorOperatingSystemVersion;\n    WORD    MajorImageVersion;\n    WORD    MinorImageVersion;\n    WORD    MajorSubsystemVersion;\n    WORD    MinorSubsystemVersion;\n    DWORD   Win32VersionValue;\n    DWORD   SizeOfImage;\n    DWORD   SizeOfHeaders;\n    DWORD   CheckSum;\n    WORD    Subsystem;\n    WORD    DllCharacteristics;\n    DWORD   SizeOfStackReserve;\n    DWORD   SizeOfStackCommit;\n    DWORD   SizeOfHeapReserve;\n    DWORD   SizeOfHeapCommit;\n    DWORD   LoaderFlags;\n    DWORD   NumberOfRvaAndSizes;\n    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];\n} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;\n```\n\n- **Magic**：表示可选头的类型。\n\n  ```C\n  #define IMAGE_NT_OPTIONAL_HDR32_MAGIC      0x10b  // 32位PE可选头\n  #define IMAGE_NT_OPTIONAL_HDR64_MAGIC      0x20b  // 64位PE可选头\n  #define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107  \n  ```\n\n  \n\n- **MajorLinkerVersion** 和 **MinorLinkerVersion**：链接器的版本号。\n\n- **SizeOfCode**：代码段的长度，如果有多个代码段，则是代码段长度的总和。\n\n- **SizeOfInitializedData**：初始化的数据长度。\n\n- **SizeOfUninitializedData**：未初始化的数据长度。\n\n- **AddressOfEntryPoint：程序入口的 RVA，对于exe这个地址可以理解为WinMain的RVA。对于DLL，这个地址可以理解为DllMain的RVA，如果是驱动程序，可以理解为DriverEntry的RVA。当然，实际上入口点并非是WinMain，DllMain和DriverEntry，在这些函数之前还有一系列初始化要完成，当然，这些不是本文的重点。**⭐⭐⭐\n\n- **BaseOfCode**：代码段起始地址的RVA。\n\n- **BaseOfData**：数据段起始地址的RVA。\n\n- **ImageBase**：映象（加载到内存中的PE文件）的基地址，这个基地址是建议，对于DLL来说，如果无法加载到这个地址，系统会自动为其选择地址。⭐⭐⭐\n\n- **SectionAlignment**：节对齐，PE中的节被加载到内存时会按照这个域指定的值来对齐，比如这个值是0x1000，那么每个节的起始地址的低12位都为0。⭐⭐⭐\n\n- **FileAlignment**：节在文件中按此值对齐，SectionAlignment必须大于或等于FileAlignment。\n\n- **MajorOperatingSystemVersion**、MinorOperatingSystemVersion：所需操作系统的版本号，随着操作系统版本越来越多，这个好像不是那么重要了。\n\n- **MajorImageVersion**、**MinorImageVersion**：映象的版本号，这个是开发者自己指定的，由连接器填写。\n\n- **MajorSubsystemVersion**、**MinorSubsystemVersion**：所需子系统版本号。\n\n- **Win32VersionValue**：保留，必须为0。\n\n- **SizeOfImage**：映象的大小，PE文件加载到内存中空间是连续的，这个值指定占用虚拟空间的大小。\n\n- **SizeOfHeaders**：所有文件头（包括节表）的大小，这个值是以FileAlignment对齐的。\n\n- **CheckSum**：映象文件的校验和。\n\n- **Subsystem**：运行该PE文件所需的子系统。\n\n- **SizeOfStackReserve**：运行时为每个线程栈保留内存的大小。\n\n- **SizeOfStackCommit**：运行时每个线程栈初始占用内存大小。\n\n- **SizeOfHeapReserve**：运行时为进程堆保留内存大小。\n\n- **SizeOfHeapCommit**：运行时进程堆初始占用内存大小。\n\n- **LoaderFlags**：保留，必须为0。\n\n- **NumberOfRvaAndSizes**：数据目录的项数，即下面这个数组的项数。\n\n- ⭐⭐⭐⭐⭐**DataDirectory**：数据目录，这是一个数组，数组的项定义如下：\n\n  ```C\n  typedef struct _IMAGE_DATA_DIRECTORY {\n      DWORD   VirtualAddress; //是一个RVA的偏移地址\n      DWORD   Size; // 对应表的大小\n  } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;\n  ```\n\n  这两个数有什么用呢 ？**一个是地址，一个是大小，可以看出这个数据目录项定义的是一个区域**。**那他定义的是什么东西的区域呢？**前面说了，**DataDirectory 是个数组**，**数组中的每一项对应一个特定的数据结构**，**包括导入表，导出表等等**，**根据不同的索引取出来的是不同的结构**，头文件里定义各个项表示哪个结构，如下面的代码所示:\n\n```C\n#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory ⭐⭐⭐   \n#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory  ⭐⭐⭐\n#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory\n#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory\n#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory\n#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table\n#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory\n//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)\n#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data\n#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP\n#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory   ⭐⭐\n#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory\n#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers\n#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table  ⭐⭐  //IAT\n#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors\n#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor\n```\n\n### 三.IMAGE_SECTION_HEADER（节表）\n\n```C\ntypedef struct _IMAGE_SECTION_HEADER {\n    Name\t\t\t\t\t\t//8个字节的块名\n    union\t\t\t\t\t\t\n    {\n        DWORD PhysicalAddress;\n        DWORD VirtualSize;\n    } Misc;                     //区块尺寸\n    DWORD VirtualAddress;\t\t//区块的RVA地址\n    DWORD SizeOfRawData;\t\t//在文件中对齐后的尺寸\n    DWORD PointerToRawData;\t\t//在文件中偏移\n    DWORD PointerToRelocations;\t//在OBJ文件中使用，重定位的偏移\n    DWORD PointerToLinenumbers;\t//行号表的偏移（供调试使用地）\n    WORD NumberOfRelocations;\t//在OBJ文件中使用，重定位项数目\n    WORD NumberOfLinenumbers;\t//行号表中行号的数目\n    DWORD Characteristics;\t\t//区块属性如可读，可写，可执行等\n} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;\n```\n\n### 四.节\n\n每个区块的名称都是唯一的，不能有同名的两个区块。\n但事实上节的名称不表示任何含义，他的存在仅仅是为了正规统一编程的时候方便程序员查看方便而设置的一个标记而已。所以将包含代码的区块命名为“.Data” （一般为.text）或者说将包含数据的区块命名为“.Code”（一般为.rdata等） 都是合法的。\n当我们要从PE 文件中读取需要的区块的时候，不能以区块的名称作为定位的标准和依据，正确方法是\n\n在节头（`IMAGE_SECTION_HEADER`）中。要定位节的地址，你可以按照以下步骤进行：\n\n1. **获取文件头**：从 PE 文件的起始部分读取 DOS 头（`IMAGE_DOS_HEADER`），然后找到 PE 头的位置。\n2. **读取可选头**：从 PE 头中读取可选头（`IMAGE_OPTIONAL_HEADER32`），确认文件类型（如 PE32）。\n3. **读取节表**：可选头后面会跟着一个或多个节头。节头的数量在可选头中指定，通常可以通过 `NumberOfSections` 字段获取。\n4. **计算节的地址**：每个节头都有一个 `VirtualAddress` 字段，表示该节在内存中的地址。你可以通过遍历节头来查找特定节的信息。\n5. **加载地址**：当 PE 文件被加载到内存中时，你可以将 `VirtualAddress` 和基址相加，以确定节的实际内存地址。\n\n各种节的描述：\n\n![](PE文件学习/3.png)\n\n### 五.其他注意\n\n##### 1.RVA 和文件偏移换算\n\n在 PE 文件格式中，RVA（Relative Virtual Address）和文件偏移之间的换算是非常重要的。以下是相关术语和它们在 PE 文件结构中的定义，以及如何进行换算的方法：\n\n### 术语及其定义\n\n1. **RVA（Relative Virtual Address）**：\n   - **定义**：相对虚拟地址，是指某个节或数据在内存中的相对地址，通常是相对于加载基址（`ImageBase`）的偏移。\n   - **结构**：在 `IMAGE_SECTION_HEADER` 中的 `VirtualAddress` 字段。\n\n2. **FOA（File Offset Address）**：\n   - **定义**：文件偏移地址，指的是文件中某个特定数据或结构的偏移位置。\n   - **结构**：在 `IMAGE_SECTION_HEADER` 中的 `PointerToRawData` 字段。\n\n3. **ImageBase**：\n   - **定义**：基址，指 PE 文件在内存中加载时的起始地址。\n   - **结构**：在 `IMAGE_OPTIONAL_HEADER` 中的 `ImageBase` 字段。\n\n### RVA 与 FOA 之间的换算\n\n#### 1. 从 RVA 转换到 FOA\n\n给定一个 RVA，可以使用以下公式转换为 FOA：\n\n```\nFOA = RVA - Section.VirtualAddress + Section.PointerToRawData\n```\n\n- **解释**：\n  - `Section.VirtualAddress`：对应节头中的 `VirtualAddress` 字段。\n  - `Section.PointerToRawData`：对应节头中的 `PointerToRawData` 字段。\n  \n#### 2. 从 FOA 转换到 RVA\n\n给定一个 FOA，可以使用以下公式转换为 RVA：\n\n```\nRVA = FOA - Section.PointerToRawData + Section.VirtualAddress\n```\n\n### 示例\n\n假设有以下节头信息：\n\n- **节名**：`.text`\n- **VirtualAddress**：`0x1000`\n- **PointerToRawData**：`0x200`\n\n那么，对于某个特定的 RVA `0x1010`，可以计算 FOA 如下：\n\n```\nFOA = 0x1010 - 0x1000 + 0x200 = 0x210\n```\n\n如果要将 FOA `0x210` 转换回 RVA：\n\n```\nRVA = 0x210 - 0x200 + 0x1000 = 0x1010\n```\n\n### 总结\n\n- **RVA** 是节在内存中的相对虚拟地址。\n- **FOA** 是节在文件中的具体偏移。\n- 使用 `IMAGE_SECTION_HEADER` 中的 `VirtualAddress` 和 `PointerToRawData` 字段进行 RVA 和 FOA 之间的换算。\n\n这些计算在 PE 文件的解析、调试和分析中是非常重要的，理解这些术语及其对应的结构定义将有助于处理 PE 文件格式。\n\n\n\n**<u>同时计算时也要考虑对齐会对RVA 与 FOA 之间的换算影响</u>**\n\n节对齐和文件对齐是 PE 文件格式中两个重要的概念，它们的主要区别如下：\n\n### 节对齐（Section Alignment）\n\n1. **定义**：\n   - 节对齐是指在 PE 文件加载到内存中时，节在内存中的对齐要求。它决定了每个节的起始地址必须是某个特定值的倍数。\n\n2. **位置**：\n   - 节对齐的值在 `IMAGE_OPTIONAL_HEADER` 结构中，字段名称为 `SectionAlignment`。\n\n3. **作用**：\n   - 确保加载到内存中的节按页对齐，以优化内存访问和提高性能。通常，`SectionAlignment` 的值为 4096 字节（一个内存页的大小）。\n\n4. **加载时的对齐**：\n   - 节对齐是在 PE 文件加载到内存后生效的。加载过程会根据 `SectionAlignment` 进行调整。\n\n### 文件对齐（File Alignment）\n\n1. **定义**：\n   - 文件对齐是指在 PE 文件中，节在文件中的对齐要求。它决定了每个节在文件中开始的位置必须是某个特定值的倍数。\n\n2. **位置**：\n   - 文件对齐的值同样在 `IMAGE_OPTIONAL_HEADER` 结构中，字段名称为 `FileAlignment`。\n\n3. **作用**：\n   - 确保在 PE 文件中，节的起始位置按照 `FileAlignment` 对齐，以便于文件的读取和解析。通常，`FileAlignment` 的值为 512 字节或 4096 字节。\n\n4. **未加载时的对齐**：\n   - 文件对齐是在 PE 文件未加载时适用的。它影响文件的存储格式，而不是内存中的布局。\n\n### 总结\n\n- **节对齐**：适用于 PE 文件加载到内存后的内存布局，确保节按页对齐。\n- **文件对齐**：适用于 PE 文件的存储格式，确保节在文件中按字节对齐。\n\n因此，节对齐和文件对齐是针对不同上下文的对齐要求，它们的值和作用有所不同。\n\n#### 2.PE文件与内存映射\n\n**就是把** **PE 文件** **从** **硬盘中** **放到** **内存中****，然后 CPU 从 内存中读取指令并执行。\n\n![](PE文件学习/a.png)\n\n![](PE文件学习/7.png)\n\n**文件中使用偏移（offset），内存中使用 VA（Virtual Address，虚拟地址）来表示位置。**\n\n**VA 指进程虚拟内存的绝对地址**，**RVA(Relative Virtual Address，相对虚拟地址)是指从某基准位置（ImageBase）开始的相对地址**。VA 与 RVA 满足下面的换算关系： **RVA + ImageBase = VA**\n\n***************************************************************\nPE 头内部信息大多是 RVA 形式存在。\n原因在于（主要是DLL）加载到进程虚拟内存的特定位置时，该位置可能已经加载了其他的 PE文件（DLL）。\n此时必须通过重定向（Relocation）将其加载到其他空白的位置，若 PE头信息使用的是 VA，则无法正常访问。\n因此使用 RVA 来重定向信息，即使发生了重定向，只要相对于基准位置的相对位置没有变化，就能正常访问到指定信息，不会出现任何问题。\n***************************************************************\n\n**当 PE 文件被执行时，PE 装载器会为 \\**进程\\** 分配 4GB 的 \\**虚拟地址空间\\**\\**（ Virtual address spaces 官方文档：\\**\\**https://docs.microsoft.com/zh-tw/windows-hardware/drivers/gettingstarted/virtual-address-spaces\\** \\**）\\**，然后把程序所占用的磁盘空间作为虚拟内存映射到这个4GB的虚拟地址空间中。一般情况下，会映射到 \\**虚拟地址空间\\** 中的 0X400000的位置。**\n\n![](PE文件学习/f.png)\n\n### Last\n\n写的PE文件分析器🌃🌃🌃\n\n```C++\n#include <iostream>\n#include <fstream>\n#include <windows.h>\n\nusing namespace std;\n\nvoid PrintDataDirectory(IMAGE_DATA_DIRECTORY dir, const char* name) {\n    cout << name << \" - RVA: 0x\" << hex << dir.VirtualAddress << \", Size: 0x\" << dir.Size << dec << endl;\n}\n\nvoid ParsePEFile(const char* filePath) {\n    // 打开文件\n    ifstream file(filePath, ios::binary | ios::in);\n    if (!file) {\n        cerr << \"无法打开文件: \" << filePath << endl;\n        return;\n    }\n\n    // 读取DOS头\n    IMAGE_DOS_HEADER dosHeader;\n    file.read(reinterpret_cast<char*>(&dosHeader), sizeof(IMAGE_DOS_HEADER));\n    if (dosHeader.e_magic != IMAGE_DOS_SIGNATURE) {\n        cerr << \"不是有效的PE文件\" << endl;\n        return;\n    }\n\n    // 跳转到PE头\n    file.seekg(dosHeader.e_lfanew, ios::beg);\n    DWORD signature;\n    file.read(reinterpret_cast<char*>(&signature), sizeof(DWORD));\n\n    if (signature != IMAGE_NT_SIGNATURE) {\n        cerr << \"PE签名无效\" << endl;\n        return;\n    }\n\n    // 读取文件头\n    IMAGE_FILE_HEADER fileHeader;\n    file.read(reinterpret_cast<char*>(&fileHeader), sizeof(IMAGE_FILE_HEADER));\n\n    // 读取可选头（32位/64位）\n    IMAGE_OPTIONAL_HEADER optionalHeader;\n    file.read(reinterpret_cast<char*>(&optionalHeader), sizeof(IMAGE_OPTIONAL_HEADER));\n\n    cout << \"PE文件解析：\" << filePath << endl;\n    cout << \"-----------------------------------\" << endl;\n\n    // 输出加载基地址、入口地址\n    cout << \"加载基地址: 0x\" << hex << optionalHeader.ImageBase << endl;\n    cout << \"入口地址: 0x\" << hex << optionalHeader.AddressOfEntryPoint << endl;\n\n    // 判断是否启用了DEP、ASLR、控制流保护、SEH\n    bool depEnabled = (optionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NX_COMPAT);\n    bool aslrEnabled = (optionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE);\n    bool cfGuardEnabled = (optionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_GUARD_CF);\n    bool sehEnabled = !(fileHeader.Characteristics & IMAGE_FILE_DLL); // SEH一般禁用DLL\n\n    cout << \"DEP启用: \" << (depEnabled ? \"是\" : \"否\") << endl;\n    cout << \"ASLR启用: \" << (aslrEnabled ? \"是\" : \"否\") << endl;\n    cout << \"控制流保护启用: \" << (cfGuardEnabled ? \"是\" : \"否\") << endl;\n    cout << \"SEH启用: \" << (sehEnabled ? \"是\" : \"否\") << endl;\n\n    // 输出数据目录项信息\n    cout << \"-----------------------------------\" << endl;\n    cout << \"数据目录项:\" << endl;\n\n    PrintDataDirectory(optionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT], \"Export Table\");\n    PrintDataDirectory(optionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT], \"Import Table\");\n    PrintDataDirectory(optionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE], \"Resource Table\");\n    PrintDataDirectory(optionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION], \"Exception Table\");\n    PrintDataDirectory(optionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY], \"Security Table\");\n    PrintDataDirectory(optionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC], \"Base Relocation Table\");\n    PrintDataDirectory(optionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG], \"Debug Directory\");\n    PrintDataDirectory(optionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS], \"TLS Table\");\n\n    // 输出所有节的名字、相对偏移、大小\n    cout << \"-----------------------------------\" << endl;\n    cout << \"节信息:\" << endl;\n\n    file.seekg(dosHeader.e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + fileHeader.SizeOfOptionalHeader, ios::beg);\n    IMAGE_SECTION_HEADER sectionHeader;\n    for (int i = 0; i < fileHeader.NumberOfSections; i++) {\n        file.read(reinterpret_cast<char*>(&sectionHeader), sizeof(IMAGE_SECTION_HEADER));\n        cout << \"节名: \" << string(reinterpret_cast<char*>(sectionHeader.Name), 8) << endl;\n        cout << \"相对虚拟地址: 0x\" << hex << sectionHeader.VirtualAddress << endl;\n        cout << \"大小: 0x\" << hex << sectionHeader.Misc.VirtualSize << dec << endl;\n        cout << \"-----------------------------------\" << endl;\n    }\n\n    file.close();\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        cerr << \"用法: \" << argv[0] << \" <PE文件路径>\" << endl;\n        return 1;\n    }\n    ParsePEFile(argv[1]);\n    return 0;\n}\n\n```\n\n```\n使用命令:./pe.exe target.exe\n```\n\n","tags":["PE"]},{"title":"Inline_hook","url":"/2024/10/29/Inline-hook/","content":"\n> [!IMPORTANT]\n>\n> inline_hook 一般的想法就是替换某个函数的第1个汇编命令 改成 jmp 目标函数的想法\n>\n> 另外需要注意的是      hook 函数与被hook处的函数 的 调用类型 要相同\n\n## 1.x86 下的Inline hook\n\nx86 下 一般都是使用jmp 指令  ： 5个字节 （0xE9 ** ** ** ** ) 后面四个字节就是偏移地址\n\n```c++\n#include<stdio.h>\n#include<Windows.h>\nint WINAPI hookMessageBox(\n    _In_opt_ HWND hWnd,\n    _In_opt_ LPCWSTR lpText,\n    _In_opt_ LPCWSTR lpCaption,\n    _In_ UINT uType)\n{\n    printf(\"%s;%s\\n\", lpText, lpCaption);\n    return 0;\n}\nvoid inlinehook(void* target, void* hook_address) {\n    unsigned char jump_hook[10] = { 0 };\n    jump_hook[0] = 0xE9;\n    int offest = (int)hook_address - (int(target) + 5);\n    *(int*)&jump_hook[1] = offest;\n    DWORD oldprotect = 0;\n    VirtualProtect(target, 4096, PAGE_EXECUTE_READWRITE, &oldprotect);\n    memcpy(target, jump_hook, 5);\n    VirtualProtect(target, 4096, PAGE_EXECUTE_READWRITE, &oldprotect);\n}\nint main()\n{\n    inlinehook(MessageBoxA, hookMessageBox);\n    //void* targetFunction = (void*)MessageBoxA;\n    //void* p2 = (void*)hookMessageBox;\n    //printf(\"Address of MessageBoxA: %p\\n\", targetFunction);\n    //printf(\"Address of HookMessageBoxA %p\\n\", p2);\n    MessageBoxA(NULL, \"hello world!\", \"inline_hook\", MB_OK);\n    return 0;\n}\n```\n\n![](Inline-hook/1.png)\n\n**上面这种inline hook 方式 会 使得 target 处的函数不能正确执行 ，一般是使用下面这种 hook 方式**\n\n![](Inline-hook/3.png)\n\n#### InlineHook.h\n\n```C++\n#pragma once\n\n#include <Windows.h>\n\ntypedef unsigned char byte;\ntypedef signed char int8_t;\ntypedef unsigned char uint8_t;\ntypedef short int16_t;\ntypedef unsigned short uint16_t;\ntypedef int int32_t;\ntypedef unsigned int uint32_t;\ntypedef long long int64_t;\ntypedef unsigned long long uint64_t;\ntypedef uint32_t boolean_t;\n\ntypedef struct _HOOK_STUB\n{\n\tbyte jz[2];\n\tbyte jnz[2];\n\tbyte flag[4];\n\tbyte nop[5];\n\tbyte jmp_handler[5];\n\tbyte origin_code[15];\n\tbyte jmp_origin_fun[5];\n\tbyte flag2[4];\n}HOOK_STUB, *PHOOK_STUB;\n\n\nclass CInlineHook\n{\npublic:\n\tCInlineHook();\n\t~CInlineHook();\n\n\tbool InstallHook(const char* ModuleName, const char* ApiName, void* HandlerAddress);\n\tbool InstallHook(void* TargetAddress, void* HandlerAddress);\n\tbool UninstallHook();\n\n\tvoid* GetOriginFunction() {\n\t\treturn m_OriginFunction;\n\t}\n\t\n\nprotected:\n\t//\n\t// 获取汇编指令长度，用于HOOK\n\t//\n\tstatic int InstructLen(void* Address);\n\tstatic const uint8_t c_opinfo[256];\n\n\nprotected:\n\tvoid InitHookStub(PHOOK_STUB HookStub);\n\n\tPHOOK_STUB m_HookStub;\n\tvoid* m_OriginFunction;\n\tvoid* m_TargetAddress;\n\tint m_HookLen;\n};\n\n\n```\n\n#### InlineHook.cpp\n\n```C++\n#include \"InlineHook.h\"\n#include <stdio.h>\n\n/**\n* info structure:\n*\t0x26 means: 6 2 (high-low, low-high)\n*\n* Bit 0:\n*\t1 - has ModR/M\n*\t0 - no ModR/M byte\n* Bit 1~3:\n*\t0 - no imm\n*\t1 - Ib, Jb\n*\t2 - Iw\n*\t3 - Iv, Iz, Jz\n*\t4 - Ib + Iw\n*\n* special cases:\n*\t1. group f6xx, f7xx: nnn = 000,001 -- uses Iz\n*\t2. 9a, ea: Ap (xxxx:xxxxxxxx), 6-byte imm\n*\t3. Ob, Ov: 4-byte long offset\n*/\n\nconst uint8_t CInlineHook::c_opinfo[256] = {\n\t/*        0 1  2 3  4 5  6 7  8 9  A B  C D  E F  */\n\t/*       ---------------------------------------  */\n\t/* 00 */ 0x11, 0x11, 0x26, 0x00, 0x11, 0x11, 0x26, 0x00,\n\t/* 10 */ 0x11, 0x11, 0x26, 0x00, 0x11, 0x11, 0x26, 0x00,\n\t/* 20 */ 0x11, 0x11, 0x26, 0x00, 0x11, 0x11, 0x26, 0x00,\n\t/* 30 */ 0x11, 0x11, 0x26, 0x00, 0x11, 0x11, 0x26, 0x00,\n\t/* 40 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t/* 50 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t/* 60 */ 0x00, 0x11, 0x00, 0x00, 0x67, 0x23, 0x00, 0x00,\n\t/* 70 */ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,\n\t/* 80 */ 0x37, 0x33, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,\n\t/* 90 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t/* A0 */ 0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00,\n\t/* B0 */ 0x22, 0x22, 0x22, 0x22, 0x66, 0x66, 0x66, 0x66,\n\t/* C0 */ 0x33, 0x40, 0x11, 0x37, 0x80, 0x40, 0x02, 0x00,\n\t/* D0 */ 0x11, 0x11, 0x22, 0x00, 0x11, 0x11, 0x11, 0x11,\n\t/* E0 */ 0x22, 0x22, 0x22, 0x22, 0x66, 0x02, 0x00, 0x00,\n\t/* F0 */ 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11,\n\t/*        0 1  2 3  4 5  6 7  8 9  A B  C D  E F  */\n\t/*       ---------------------------------------  */\n\t0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, /* 0F 00 */\n\t0x11, 0x11, 0x11, 0x11, 0x10, 0x00, 0x00, 0x01, /* 0F 10 */\n\t0x11, 0x11, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, /* 0F 20 */\n\t0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, /* 0F 30 */\n\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, /* 0F 40 */\n\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, /* 0F 50 */\n\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, /* 0F 60 */\n\t0x33, 0x11, 0x11, 0x10, 0x00, 0x00, 0x11, 0x11, /* 0F 70 */\n\t0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, /* 0F 80 */\n\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, /* 0F 90 */\n\t0x00, 0x01, 0x31, 0x00, 0x00, 0x01, 0x31, 0x11, /* 0F A0 */\n\t0x11, 0x11, 0x11, 0x11, 0x00, 0x11, 0x11, 0x11, /* 0F B0 */\n\t0x11, 0x31, 0x33, 0x31, 0x00, 0x00, 0x00, 0x00, /* 0F C0 */\n\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, /* 0F D0 */\n\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, /* 0F E0 */\n\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10  /* 0F F0 */\n\t/*        0 1  2 3  4 5  6 7  8 9  A B  C D  E F  */\n\t/*       ---------------------------------------  */\n};\n\nenum cpu_mode_t { cm_legacy = -1, cm_compat = 0, cm_64bit = 1 };\n\nint CInlineHook::InstructLen(void* Address)\n{\n\tenum cpu_mode_t cm = cm_compat;\n\tregister uint8_t* p = (uint8_t*)Address;\n\tregister uint8_t b = 0;\n\tregister boolean_t pre_66 = false;\n\tuint8_t info;\n\tregister int tbl_fixup = 0;\n\tregister uint8_t i_info = 0;\n\tregister uint8_t modrm = 0;\n\n\tif (!Address)\n\t\treturn -1;\n\n\twhile (1)\n\t{\n\t\tb = *p++;\n\n\t\tif (b >= 0x40 && b <= 0x4f && cm == cm_64bit)\n\t\t\tcontinue;\n\t\telse if (b == 0x66) {\n\t\t\tpre_66 = true;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (b == 0xf0 || b == 0xf2 || b == 0xf3 ||\n\t\t\tb == 0x26 || b == 0x2e || b == 0x36 ||\n\t\t\tb == 0x3e || b == 0x64 || b == 0x65 ||\n\t\t\tb == 0x67)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\tif (b == 0x0f) {\n\t\tb = *p++;\n\t\ttbl_fixup = 128;\n\t}\n\n\tinfo = c_opinfo[(b >> 1) + tbl_fixup];\n\tinfo = ((b % 2) ? info : (info >> 4)) & 0x0f;\n\ti_info = (info >> 1) & 7;\n\n\tif (info & 0x01) {\n\t\t/* has modrm */\n\t\tmodrm = *p++;\n\t\tdo {\n\t\t\tregister uint8_t sib = 0;\n\t\t\tboolean_t has_sib = false;\n\t\t\tregister uint8_t tmp = 0;\n\n\t\t\tif ((modrm & 0xc0) == 0xc0)\t/* mod == 3 */\n\t\t\t\tbreak;\n\n\t\t\tif (cm != cm_legacy && (modrm & 0x07) == 4) {\n\t\t\t\thas_sib = true;\n\t\t\t\tsib = *p++;\n\t\t\t}\n\t\t\t/* displacement */\n\t\t\ttmp = has_sib ? sib : modrm;\n\t\t\tif (!(modrm & 0xc0)) {\t/* mod == 00b */\n\t\t\t\tif ((tmp & 0x07) == 5)\n\t\t\t\t\tp += (cm == cm_legacy) ? 2 : 4;\n\t\t\t}\n\t\t\telse if ((modrm & 0xc0) == 0x40) {\t/* mod == 01b */\n\t\t\t\t++p;\n\t\t\t}\n\t\t\telse {\t/* mod == 0x10b */\n\t\t\t\tp += (cm == cm_legacy) ? 2 : 4;\n\t\t\t}\n\t\t} while (0);\n\t}\n\n\t/* special cases */\n\tdo\n\t{\n\t\tregister uint8_t tmp = (modrm & 0x38) >> 3;\t/* nnn */\n\t\tif (tmp == 0 || tmp == 1) {\n\t\t\tif (b == 0xf6)\n\t\t\t\ti_info |= 1;\n\t\t\telse if (b == 0xf7)\n\t\t\t\ti_info |= 3;\t/* Iz */\n\t\t}\n\t\tif (b == 0x9a || b == 0xea)\t/* Ap */\n\t\t\tp += 6;\n\t\tif (b >= 0xa0 && b <= 0xa3)\n\t\t\tp += 4;\n\n\t} while (0);\n\n\t/* take care of immediate value */\n\tswitch (i_info) {\n\tcase 0:\tbreak;\n\tcase 1:\t++p; break;\n\tcase 2:\tp += 2;\tbreak;\n\tcase 3:\tp += pre_66 ? 2 : 4; break;\n\tcase 4:\tp += 3;\tbreak;\n\t}\n\n\treturn (int)(p - (uint8_t*)Address);\n}\n\n\n\nCInlineHook::CInlineHook()\n{\n\tm_HookStub = NULL;\n\tm_OriginFunction = NULL;\n\tm_TargetAddress = NULL;\n\tm_HookLen = 0;\n}\n\n\nCInlineHook::~CInlineHook()\n{\n\tif (m_HookStub)\n\t{\n\t\tdelete m_HookStub;\n\t\tm_HookStub = NULL;\n\t}\n}\n\nvoid CInlineHook::InitHookStub(PHOOK_STUB HookStub)\n{\n\tif (HookStub == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tZeroMemory(HookStub, sizeof(HOOK_STUB));\n\tHookStub->jz[0] = 0x74;\n\tHookStub->jz[1] = 0x06;\n\tHookStub->jnz[0] = 0x75;\n\tHookStub->jnz[1] = 0x04;\n\tmemcpy(HookStub->flag, \"xuan\", sizeof(HookStub->flag));\n\tmemset(HookStub->nop, 0x90, sizeof(HookStub->nop));\n\tHookStub->jmp_handler[0] = 0xE9;\n\tmemset(HookStub->origin_code, 0x90, sizeof(HookStub->origin_code));\n\tHookStub->jmp_origin_fun[0] = 0xE9;\n\tmemcpy(HookStub->flag2, \"yuan\", sizeof(HookStub->flag2));\n}\n\nbool CInlineHook::InstallHook(const char* ModuleName, const char* ApiName, void* HandlerAddress)\n{\n\tHMODULE hModule = NULL;\n\tvoid* targetAddress = NULL;\n\tbool bRet = false;\n\n\tdo \n\t{\n\t\thModule = GetModuleHandleA(ModuleName);\n\t\tif (!hModule)\n\t\t\tbreak;\n\n\t\ttargetAddress = GetProcAddress(hModule, ApiName);\n\t\tif (!targetAddress)\n\t\t\tbreak;\n\n\t\tbRet = InstallHook(targetAddress, HandlerAddress);\n\n\t} while (false);\n\n\treturn bRet;\n}\n\nbool CInlineHook::InstallHook(void* TargetAddress, void* HandlerAddress)\n{\n\tDWORD OldPageProperty = 0;\n\n\tif (TargetAddress == NULL || HandlerAddress == NULL || m_HookStub)\n\t{\n\t\treturn false;\n\t}\n\n\t//\n\t// 计算要HOOK的字节长度\n\t//\n\tint hook_len = 0;\n\tuint8_t* start_address = (uint8_t*)TargetAddress;\n\twhile (hook_len < 5)\n\t{\n\t\tint instruct_len = InstructLen(start_address);\n\t\tif (instruct_len <= 0 || instruct_len >= 10)\n\t\t\tbreak;\n\n\t\thook_len += instruct_len;\n\t\tstart_address += instruct_len;\n\t}\n\n\t//\n\t// 分配中间跳指令区，并设置可执行属性\n\t//\n\tm_HookStub = new HOOK_STUB();\n\tif (m_HookStub == NULL)\n\t{\n\t\treturn false;\n\t}\n\tif (!VirtualProtect(m_HookStub, sizeof(HOOK_STUB), PAGE_EXECUTE_READWRITE, &OldPageProperty))\n\t{\n\t\tdelete m_HookStub;\n\t\tm_HookStub = NULL;\n\t\treturn false;\n\t}\n\n\t//\n\t// 准备hook中间跳转指令\n\t//\n\tInitHookStub(m_HookStub);\n\tmemcpy(m_HookStub->origin_code, TargetAddress, hook_len);\n\t*((unsigned long *)(&m_HookStub->jmp_handler[1])) = (unsigned long)HandlerAddress - ((unsigned long)&m_HookStub->jmp_handler + 5);\n\t*((unsigned long *)(&m_HookStub->jmp_origin_fun[1])) = ((unsigned long)TargetAddress + hook_len) - ((unsigned long)&m_HookStub->jmp_origin_fun + 5);\n\n\n\t//\n\t// 准备Hook目标入口跳转指令\n\t//\n\tbyte jmp_entry[20] = { 0 };\n\tmemset(jmp_entry, 0x90, sizeof(jmp_entry));\n\tjmp_entry[0] = 0xE9;\n\t*((unsigned long*)(&jmp_entry[1])) = (unsigned long)m_HookStub - ((unsigned long)TargetAddress + 5);\n\n\t//\n\t// 开始安装钩子\n\t//\n\tOldPageProperty = 0;\n\tVirtualProtect(TargetAddress, hook_len, PAGE_READWRITE, &OldPageProperty);\n\tmemcpy(TargetAddress, jmp_entry, hook_len);\n\tVirtualProtect(TargetAddress, hook_len, OldPageProperty, &OldPageProperty);\n\n\tm_OriginFunction = &m_HookStub->origin_code;\n\tm_TargetAddress = TargetAddress;\n\tm_HookLen = hook_len;\n\treturn true;\n}\n\nbool CInlineHook::UninstallHook()\n{\n\tif (m_HookStub == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\tDWORD OldPageProperty = 0;\n\n\tVirtualProtect(m_TargetAddress, m_HookLen, PAGE_READWRITE, &OldPageProperty);\n\tmemcpy(m_TargetAddress, m_HookStub->origin_code, m_HookLen);\n\tVirtualProtect(m_TargetAddress, m_HookLen, OldPageProperty, &OldPageProperty);\n\n\tdelete m_HookStub;\n\tm_HookStub = NULL;\n\n\treturn true;\n\n}\n```\n\n#### Test.cpp\n\n```C++\n// Test.cpp : 定义控制台应用程序的入口点。\n//\n\n#include <Windows.h>\n#include \"InlineHook.h\"\n\n#include <map>\n#include <string>\nusing namespace std;\n\nmap<string, CInlineHook*> hookTable;\n\ntypedef int (WINAPI *PFN_MessageBoxA) (\n\t\t\t\t\t\t  __in_opt HWND hWnd,\n\t\t\t\t\t\t  __in_opt LPCSTR lpText,\n\t\t\t\t\t\t  __in_opt LPCSTR lpCaption,\n\t\t\t\t\t\t  __in UINT uType);\nint WINAPI HookMessageBoxA(\n\t\t\t\t__in_opt HWND hWnd,\n\t\t\t\t__in_opt LPCSTR lpText,\n\t\t\t\t__in_opt LPCSTR lpCaption,\n\t\t\t\t__in UINT uType)\n{\n\tprintf(\"%s: %s\\n\", lpText, lpCaption);\n\n\tCInlineHook* hook = hookTable[\"MessageBoxA\"];\n\n\tPFN_MessageBoxA pfn_MessageBoxA = (PFN_MessageBoxA)hook->GetOriginFunction();\n\n\tpfn_MessageBoxA(hWnd, lpText, lpCaption, uType);\n\n\treturn 0;\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n\n    CInlineHook hook;\n\t\n    hook.InstallHook(\"user32.dll\", \"MessageBoxA\", HookMessageBoxA);\n\thookTable.insert(pair<string, CInlineHook*>(\"MessageBoxA\", &hook));\n    \n\tMessageBoxA(NULL, \"this is my Blog!\", \"@Xhani\", MB_OK);\n\thookTable[\"MessageBoxA\"]->UninstallHook();\n\treturn 0;\n}\n```\n\n**此hook 方法不会 影响原函数的正确 执行**\n\n![](Inline-hook/4.png)\n\n###### *Todo1.编程实现HOOK WriteFile 这个Windows API，实现每次调用这个函数的时候，在写入的数据后面增加一个字符串:\"xhani!!!\"。然后程序里尝试打开一个文件，并写入一些数据，最后打开文件看看是否有这个字符串内容。*\n\n#### Todo1.cpp\n\n###### 1.方法一\n\n```C++\n// Todo1.cpp : 定义控制台应用程序的入口点。\n//\n#include <Windows.h>\n#include \"InlineHook.h\"\n#include<string.h>\n\n#include <map>\n#include <string>\nusing namespace std;\n\nmap<string, CInlineHook*> hookTable;\n\ntypedef\nBOOL\n(WINAPI* PFN_WriteFile)(\n\t_In_ HANDLE hFile,\n\t_In_reads_bytes_opt_(nNumberOfBytesToWrite) LPCVOID lpBuffer,\n\t_In_ DWORD nNumberOfBytesToWrite,\n\t_Out_opt_ LPDWORD lpNumberOfBytesWritten,\n\t_Inout_opt_ LPOVERLAPPED lpOverlapped);\n\nBOOL\nWINAPI\nHookWriteFile(\n\t_In_ HANDLE hFile,\n\t_In_reads_bytes_opt_(nNumberOfBytesToWrite) LPCVOID lpBuffer,\n\t_In_ DWORD nNumberOfBytesToWrite,\n\t_Out_opt_ LPDWORD lpNumberOfBytesWritten,\n\t_Inout_opt_ LPOVERLAPPED lpOverlapped\n)\n{\n\tCInlineHook* hook = hookTable[\"WriteFile\"];\n\n\tconst char  str[] = \"Xhani!!!\";\n\tsize_t len = strlen(str) + nNumberOfBytesToWrite;\n\tchar *newbuffer=(char *)malloc(len+1);\n\tif (newbuffer == NULL) return false;\n\tmemcpy(newbuffer,lpBuffer,nNumberOfBytesToWrite);\n\tmemcpy(newbuffer+nNumberOfBytesToWrite-1, str, strlen(str)+1);\n\tnNumberOfBytesToWrite += strlen(str);\n    \n\tPFN_WriteFile pfn_WriteFile = (PFN_WriteFile)hook->GetOriginFunction();\n\t\n\tpfn_WriteFile(hFile, newbuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);\n\treturn true;\n}\n\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n\tHANDLE hFile = CreateFile(\n\t\tL\"example.txt\",            // 文件名\n\t\tGENERIC_WRITE,           // 写入访问权限\n\t\t0,                       // 不共享\n\t\tNULL,                    // 默认安全性\n\t\tCREATE_ALWAYS,          // 如果文件存在则覆盖\n\t\tFILE_ATTRIBUTE_NORMAL,   // 普通文件\n\t\tNULL                     // 无模板文件\n\t);\n\tCInlineHook hook;\n\thook.InstallHook(\"kernel32.dll\", \"WriteFile\", HookWriteFile);\n\n\thookTable.insert(pair<string, CInlineHook*>(\"WriteFile\", &hook));\n\t\n\tchar buffer[]=\"1112211213\";\n\t//fgets(buffer, sizeof(buffer), stdin);\n\tDWORD bytesWritten;\n\n\tWriteFile(hFile, buffer,sizeof(buffer),&bytesWritten,NULL);\n\t\n\thookTable[\"WriteFile\"]->UninstallHook();\n\tCloseHandle(hFile);\n\treturn 0;\n}\n```\n\n###### 2.方法二\n\n```C++\n// 使用backup  拷贝修改处的指令\n#include<windows.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nvoid* Backup;\n#define BUFFER_SIZE  1024\n\nvoid inline_hook(void* target, void* hook_address, void* Backup);\nvoid uninstall_hook(void* target, void* backup);\n\nBOOL WINAPI hookWriteFile(\n     HANDLE hFile,\n    LPCVOID lpBuffer,\n     DWORD nNumberOfBytesToWrite,\n     LPDWORD lpNumberOfBytesWritten,\n     LPOVERLAPPED lpOverlapped\n)\n{\n    uninstall_hook(WriteFile,Backup);\n    \n    char str[] = \"Xhani!!!!!\";\n    size_t NewSize = strlen(str) + nNumberOfBytesToWrite;\n    char* buffer = (char*)malloc(NewSize+1);\n    if (buffer == NULL) return false;\n    memcpy(buffer,lpBuffer ,nNumberOfBytesToWrite);\n    memcpy(buffer + nNumberOfBytesToWrite, str,strlen(str)+1);\n    nNumberOfBytesToWrite += strlen(str);\n    \n    bool success = WriteFile(hFile, buffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);\n    \n    inline_hook(WriteFile,hookWriteFile,Backup);//  安装钩子，确保下次是调用到钩子\n    return success;\n}\nvoid inline_hook(void* target, void* hook_address,void *Backup)\n{\n    unsigned char jump_Code[10] = { 0 };\n    jump_Code[0] = 0xE9;\n    int offest = (int)hook_address - (int)target - 5;\n    *(int*)&jump_Code[1] = offest;\n    DWORD oldproperty = 0;\n    VirtualProtect(target, sizeof(jump_Code), PAGE_EXECUTE_READWRITE, &oldproperty);\n    memcpy(Backup, target, 5);\n    memcpy(target, jump_Code, 5);\n    VirtualProtect(target, sizeof(jump_Code), oldproperty, &oldproperty);\n    return;\n}\n\nvoid uninstall_hook(void* target, void* backup) {\n    DWORD oldproperty = 0;\n    VirtualProtect(target, 4096, PAGE_EXECUTE_READWRITE, &oldproperty);\n    memcpy(target, backup, 5);\n    VirtualProtect(target, 4096, oldproperty, &oldproperty);\n    return;\n}\nint main()\n{\n    HANDLE hFile = CreateFile(\n        L\"example.txt\",            // 文件名\n        GENERIC_WRITE,           // 写入访问权限\n        0,                       // 不共享\n        NULL,                    // 默认安全性\n        CREATE_ALWAYS,          // 如果文件存在则覆盖\n        FILE_ATTRIBUTE_NORMAL,   // 普通文件\n        NULL                     // 无模板文件\n    );\n    Backup = malloc(5);\n    if (hFile != INVALID_HANDLE_VALUE) {\n        DWORD bytesWritten; // 实际写入的字节数\n        char buffer[] = \"123456\";\n        inline_hook(WriteFile, hookWriteFile,Backup);\n        WriteFile(hFile, buffer, strlen(buffer), &bytesWritten, NULL);\n    }\n    CloseHandle(hFile);\n    free(Backup);\n    return 0;\n}\n```\n\n\n\n## 2.x64 位下的Inline hook\n\n#### 需要注意的是x64 下的 jmp 指令实际是 14个字节(<u>间接跳转</u>)  ：  jmp指令(FF 25)+ offest1(4字节)+0ffest2(8字节)  [因为64位下寻址更慢] \n\n> [!NOTE]\n>\n> **首先是计算出  jmp + offset1 的地址p1 ,然后寻址到p1处，在计算出p1+offest2 ,即为目标地址**\n\n\n\n```c++\n#include<stdio.h>\n#include<Windows.h>\nvoid sh() {\n    printf(\"true\");\n    return;\n}\nvoid sa()\n{\n    printf(\"false\");\n    return;\n}\nvoid inlinehook(__int64* target, __int64* hook_address) {\n    char jump_hook[14] = {0xFF,0x25,00,00,00,00,00,00,00,00,00,00,00,00 };\n    __int64* p = (_int64*)&hook_address;\n    memcpy(jump_hook + 6,p , sizeof(void*));\n \t//char jump_hook[] = {0xFF,0x25,0x01,00,00,00,00,00,00,00,00,00,00,00,00 };\n \t//__int64* p = (_int64*)&hook_address;\n \t//memcpy(jump_hook + 7,p , sizeof(void*));\n    DWORD oldprotect = 0;\n    VirtualProtect(target, sizeof(jump_hook), PAGE_EXECUTE_READWRITE, &oldprotect);\n    memcpy(target, jump_hook, sizeof(jump_hook));\n    VirtualProtect(target, sizeof(jump_hook), oldprotect, &oldprotect);\n    return;\n}\nint main()\n{\n    inlinehook((__int64 *)sa,(_int64 *)sh);\n    sa();\n    return 0;\n}\n```\n\n![](Inline-hook/2.png)\n\n\n\n","tags":["hook"]},{"title":"常见汇编","url":"/2024/09/14/deassembly-md/","content":"\n# if_else:\n\n```\n\t\tcmp a,b\n\t\tje 0x0001\n\t\t操作2 Yes\n\t\tjmp 0x0002\n0x0001:\t操作3 NO\n0x0002:\n```\n\n![](deassembly-md/image-20240914194223239.png)\n\n# switch case:\n\n```\n\t\t操作1\n\t\tcmp  a,400\n\t\tjg 0x000000\n\t\tcmp a,400\n\t\tje 0x000001\n\t\tcmp a,300\n\t\tje 0x00002\n\t\tcmp a,200\n\t\tje 0x0003\n\t\tjmp 0x0004           \n\t\t操作2  \n\t\tjmp 0x0004         //实际上是有break;\n\t\t操作3\n\t\tjmp 0x0004 \n\t\t操作4\n\t\tjmp 0x0004\n\t\t操作5\n0x0004:\n```\n\n![](deassembly-md/image-20240914194329734.png)\n\n# while()\n\n```\n0x0000: cmp a,100\n      \tjle 0x00001\n\t\t操作\n\t\tjmp 0x0000\n0x00001:\n```\n\n![](deassembly-md/image-20240914195237570.png)\n\n# do  while()\n\n```\n0x00001:操作\n\t\tcmp a,100\n\t\tjle  0x00001\n```\n\n![](deassembly-md/image-20240914195647559.png)\n\n# for()\n\n```\n\t\tmov dowrd ptr[ebp-8],1\n\t\tjmp 0x00001\n0x00003:操作\n       \tadd/sub/mul/div ecx,dowrd ptr[ebp-8]\n0x00001:cmp ecx,dowrd ptr[ebp-8]\n\t\tjg 0x00002\n\t\t操作\n\t\tjmp 0x00003\n0x00002:\n```\n\n![](deassembly-md/image-20240914195836157.png)\n","tags":["汇编"]},{"title":"网络空间搜索引擎2","url":"/2024/05/23/网络空间搜索引擎2/","content":"\n# shodan\n\n使用文档：https://xz.aliyun.com/t/2070?time__1311=n4%2BxnieDqmqqB7DuDBTroGkYDkQG8Y%2FRB%2F%2BeD&alichlgref=https%3A%2F%2Fwww.google.com%2F\n\nshodan的查询快捷语句：https://github.com/jakejarvis/awesome-shodan-queries\n\nshodan的py脚本：https://github.com/random-robbie/My-Shodan-Scripts\n\n## 1.shodan.io\n\n**shodan搜索使用文档：https://help.shodan.io/the-basics/search-query-fundamentals**\n\nkali上内置shodan\n\n## 2.shodan的功能：\n\n- 地图\n- 监控\n- 截图\n- 过滤器\n\n## 3.shodan常见命令：\n\n```\nshodan host 172.67.167.88\n```\n\n```\nshodan count apache\n```\n\n```\nshodan stats port:445 SMB\n```\n\n","tags":["web"]},{"title":"网络空间搜索引擎1","url":"/2024/05/23/网络空间搜索引擎1/","content":"\n## 1.什么是网络空间：Cyber space\n\n搜索引擎：goole诞生————网页\n\n发展：图片 音乐 声音\n\n进一步：\n\n| 网络系统 | 网络设备                 | 工业系统                 |\n| -------- | ------------------------ | ------------------------ |\n| CDN      | 手机                     | 交通信号灯  公园控制系统 |\n| IDS      | 平板                     | 核电站                   |\n| CMS      | 交换机 路由器 网络摄像头 | 加油站                   |\n| 办公软件 | 私人网盘                 | 电网                     |\n| 数据库   | 打印机  ATM 机器人       | 企业大屏幕               |\n\n## 2.网络空间搜索引擎：\n\n##### 怎么扫描：1.用网络工具：zmap nmap  2.方式：IP库 枚举\n\n怎么标识设备：\n\n- ip:域名\n\n- MAC\t\n\n- 爬虫：url\n\n- 开放系统\n- 物理地址\n- 操作系统\n- 设备类型\n\n## 3.实行威胁地图：fireeye\n\n## 4.安全性\n","tags":["web"]},{"title":"Google_hacking","url":"/2024/05/23/Google-hacking/","content":"\n## 1.语法工具：pdf文档：https://web.archive.org/web/20140822191407/http://www.boris-koch.de/wp-content/uploads/2011/01/Liste-Google-Hacking.pdf\n\n\n\n## 2.一些运算符：\n\n**完全匹配:**\n\n```\n\"网络安全\"\n```\n\n**任意词语：**\n\n```\n1 or 2\n```\n\n**不包含：**\n\n```\nburp_suite - xxx\n```\n\n**数字范围：**\n\n```\nnumber..number\n```\n\n## 3.高级语法\n\n**1.只搜索某个网站的内容：**\n\n```\nsite:zhihu.com\n```\n\n**2.网页内容包括：**\n\n```\nallintext:Powered by Discuz\nintext：Powered by Discuz\n```\n\n###### 标题：是html网页标签的标题\n\n **3.标题出现：**\n\n```\nintitle：\nallintitle:\n```\n\n**4.url地址包括：**\n\n```\nallinurl:admin.php\ninurl:index.php?id=1\n```\n\n**5.文件类型：**\n\n```\nfiletype：pdf\n```\n\n**6.index of**\n\n```\nintitle:index of\n```\n\n##  4.google语法数据库：\n\nhttps://www.exploit-db.com/google-hacking-database\n\nhttps://github.com/BullsEye0/google_dork_list\n\n## 5.工具：\n\ngithub搜索：Google hcaking \n\n​\t\t\tGoogle dorks \n"},{"title":"WAF_difference","url":"/2024/05/16/WAF_difference/","content":"\n# WAF:web应用防火墙\n\n### 1.作用（简单的）\n\n![image1](WAF_difference/1.png)\n\n### 2.WAF识别思路：\n\n1.[0xInfection/Awesome-WAF: 🔥 Web-application firewalls (WAFs) from security standpoint. (github.com)](https://github.com/0xInfection/Awesome-WAF)\n\n2.[CSecGroup/wafid: Wafid identify and fingerprint Web Application Firewall (WAF) products. (github.com)](https://github.com/CSecGroup/wafid)\n\n### 3.如何触发waf拦截：\n\n##### 1.工具：kali:wafw00f\n\n```\nwafw00f https://pinpai.smzdm.com/\n```\n\n```\nnmap www.12306.cn --script=http-waf-detect.nse\n```\n\n**必须是动态地址**：\n\n```\nsqlmap -u \"xxx.com?id=1\" --identify-waf\n```\n\n","tags":["web"]},{"title":"CDN_difference","url":"/2024/05/16/CDN-difference/","content":"\n### 1.CDN是什么：[CDN图解（秒懂 + 史上最全） - 疯狂创客圈 - 博客园 (cnblogs.com)](https://www.cnblogs.com/crazymakercircle/p/14978513.html)\n\n### 2.如何获取CDN背后的真实ip\n\n1.ping\n\n2.\n\n```\nnslookup 域名\n```\n\n3.超级ping\n\n4.Kali工具:lbd\n\n5.国内：cdn.chinaz.com\n\n国外cdnplanet.com/tools/cdnfinder\n\n6.脚本：\n\nhttps://github.com/boy-hack/w8fuckcdn/\n\nhttps://gitghub.com/3xp10it/xcdn\n","tags":["web"]},{"title":"CMS_judgement","url":"/2024/05/15/CMS-judgement/","content":"\n# CMS的指纹识别\n\n## 1.识别对象：\n\n#### 1.**CMS信息**：内容管理系统\n\n2.前端技术：\n\n3.开发语言\n\n4.web服务器\n\n5.应用服务器\n\n6.操作系统\n\n#### 7.CDN的信息\n\n#### 8.WAF信息\n\n## 2.CMS：\n\n各类开源的CMS：企业，博客，论坛，问答，知识百科，门户建站，在线教育建站，人才招聘网站\n\n## 3.CMS识别思路：\n\n###### 1.版权信息\n\n###### 2.特定文件MD5值:(https://github.com/Lucifer1993/cmsprint/blob/master/cmsprint.json)\n\n###### 3.查看页面原代码:分析代码\n\n###### 4.查看特定文件分析：如网站的robots .txt文件\n\n## 4.CMS工具：\n\n###### 1.kali工具：whatweb\n\n```kali\n`whatweb  -v www.coolshell.cn`\n```\n\n\n\n###### 2.浏览器插件：Wappalyzer,whatruns\n\n###### 3.https://github.com/Tuhinshubhra/CMSeek\n\n###### 4.http://finger.tidesec.com/\n\n","tags":["web"]},{"title":"namp的使用","url":"/2024/05/14/Use_nmap/","content":"\n# 1.nmap的使用：[](https://blog.csdn.net/weixin_49998039/article/details/125242779)\n\n### 1.类别：\n\nopen:端口开启\n\nfiltered:被防火墙阻止扫描\n\nclosed：端口关闭\n\nunfiltered：无法确定的\n\n### 2.nmap的参数\n\nnmap -sV:版本检测\n\n-PN:绕过ping命令\n\n-O：操作系统检测，1-6\n\n-T：设置扫描速度\n\n-sP：主机存活性\n\n-Ss:SYN方式\n\n-ST:三次握手\n\n-SP:没有扫描\n\n-pn:🈲ping\n\n-Su:udp的数据包\n\n-sF:FIN的方式\n\n### 3.范围内：\n\n192.168.1.1-4\n\n### 4.注意其他工具的结合：masscan:[](https://blog.csdn.net/2302_82189125/article/details/135999466)\n\nfofa.info，fofa-view插件\n\n### 5.常见端口\n\nThis is a img\n\n![image](Use_nmap/1.png)\n","tags":["web"]},{"title":"端口信息","url":"/2024/05/10/端口信息/","content":"\n## 1.端口扫描和代码实现：\n\n1.`windows :netstat -aon|findstr 3306`\n\n`linux:netstat -an|grep 3306`\n\n2.对端口发数据包扫：\n\n命令：`wget ip 80`\n\n`telnet ip 80`\n\n`nc -vz ip 445`\n\n3.工具\n\n扫描主机，端口，探测操作系统，软件版本**zenmap**\n\nnmap 使用文档 \n\n**dirsearch脚本**\n\n**masscan**\n\n\n\n4.端口类型：\n\n文件共享：\n\n远程连接：\n\nweb应用：\n\n数据库服务\n\n网路常见端口\n\n特殊服务端口\n\n","tags":["web"]},{"title":"ip信息收集","url":"/2024/05/10/ip信息收集/","content":"\n# ip信息收集：\n\n## 1.DNS类型\n\n##### 1.本地域名服务器，根域名服务器，顶级域名，授权域名\n\n##### 2.迭代查询，递归查询\n\n## 2.ping/nslookup\n\n##### ping:应用层 \n\n命令：`nslookup -type=\"MS\" baidu.com`\n\n## 3.IP归属：\n\n1.ipwhois.cnnic.cn\n\n2.ip138.com\n\n## 4.CDN服务：\n\n#### 要找到CDN背后的真实ip\n\n###### 1.超级ping\n\n######  2.历史DNS:dnshistory  \n\n###### 3.通过子域名\n\n###### 4.国外主机解析:dnscheck,webpagetest.org\n\n###### 5.邮件，SSL证书，手机抓包\n\n\n\n\n\n","tags":["web"]},{"title":"域名信息收集","url":"/2023/11/17/域名信息/","content":"\n#   1.域名信息\n\n## 1.分类：\n\n国际域名：com,net,org,gov,edu,mil,int\n\n国别：cn,uk,us,\n\n新顶级域名：biz,name,pro,info,coop,museum\n\n## 2.域名联系人信息:姓名，邮箱，手机号\n\n### 1.域名查询\n\n#### 1.阿里云\n\n#### 2.whois.chinaz.com\n\n#### 3.whoissoft.com\n\n#### 4.whois.cnnic.cn\n\n#### 5.kail命令\n\n```ABAP\nwhois 域名\n```\n\n### 2.域名反差：\n\n#### 1.whois.chinaz.com\n\n### 3.备案信息\n\n#### 1.beian.miit.gov.cn\n\n#### 2.beian88.com\n\n#### 3.天眼查\n\n### 3.子域名：\n\n#### 1.例如：news.baidu.com\n\n**工具：1.Layer   2. subDomainsBrute**\n\n**字典拆解，枚举**\n\n### DNS服务：\n\nDNS服务器\n1.主机记录\n\n记录类型：A:指定ip地址，CNAME：将一个域名指向另一个域名，AAAA，MX，TXT，NS：域名服务器记录\n\n2.查询：\n\n[域名解析查询(A/Txt/Cname/Mx/Srv/Aaaa...) (dbcha.cn)](http://dbcha.cn/)\n\nnetcraft\n\njsons.cn\n\nkail工具：maltego\n\n","tags":["web"]}]