[{"title":"VMP_virtual_ISA","url":"/2025/09/15/VMP_virtual_ISA/","content":"\n# 0.VMP的工作原理\n\n### 1.VMP实现虚拟化的方案\n\n- 虚拟机的寄存器：在内存开辟一段连续的区域当成虚拟机的寄存器，业界称之为VM_CONTEXT，某些版本的VMP用EDI指向这个区域\n-  <font color='red'>虚拟机的堆栈: 这个和物理机是一样的，直接在内存开辟就好。VMP还是用EBP指向栈顶</font>\n-  虚拟机的指令：不同版本VMP的指令是不一样的，这样可以在一定程度上防止VMP本身被破解，业界俗称VM_DATA\n-  虚拟机的EIP：业界俗称veip，某些版本的VMP用ESI替代，指向VM_DATA，用以读取虚拟CPU需要执行的指令；\n\n###   2、VMP虚拟机的执行流程\n\n　　（1）想想启动VT时，是不是要先开辟一段内存空间，把当前guestOS部分寄存器的值保存好？VMP也一样，先保存物理寄存器的值，后续退出VM后才能还原\n\n​    （2）让vEIP从VM_DATA读取虚拟机的指令(pcode)\n\n​    （3）由于虚拟机的指令和物理CPU完全不同，那么在指令读取后，该怎么去执行了？举个栗子：比如0x1表示入栈，0x2表示出栈，0x3表示寄存器之间互相传数据（当然实际的指令可能不会这么简单，VMP每个版本的指令集都不同），这些指令该怎么执行了？在VMP中，有个概念叫handler，专门根据不同的指令执行不同的操作（当然这些操作VMP事先都定义好了）。这个和VT中VMX的handler作用类似：根据不同的异常有不同的处理方法（我个人猜测VMP的作者肯定借鉴了VT的原理和思路）；\n\n　　    为了达到这种不同指令执行不同handler分支的效果，编码实现层面通常用switch+case实现，用于将不同的指令跳转到不同的分支执行，业界俗称dispatcher。具体到汇编代码，switch+case一般的汇编形式为：<font color='red'>mov ecx,dword ptr ds:[eax*4+base]（注意寄存器可能会变成其他的，但这 **xxx\\*4+基址的形式不会变**） </font>, 这是比较明显的特征，用以用来定位VMP的dispatcher。\n\n　　（4）执行完一个handler，vEIP接着指向下VM_DATA的下一个指令，然后重复（2）-（4）这几个步骤；\n\n**以VMP1.1版本的加密为例子**\n\n```C++\n#include <iostream>\n__declspec(naked) void test() {\n    __asm {\n        mov eax, 0x12345678\n        ret\n    }\n}\nint main()\n{\n    test();\n    std::cout << \"Hello VMP!\\n\";\n\n    system(\"pause\");\n    \n    return 0;\n\n}\n```\n\n![image-20250915205351612](VMP_virtual_ISA/image-20250915205351612-1757940832925-7.png)\n\n对test()函数内部代码进行VMP加密，x32dbg调试\n\n1.mov eax 0x12345678指令进行了加密\n\n\n\n![image-20250915205215481](VMP_virtual_ISA/image-20250915205215481-1757940739811-3-1757940744866-5.png)\n\n0x40AFDD 就是pcode的地址\n\n![image-20250915205458524](VMP_virtual_ISA/image-20250915205458524-1757940900720-9.png)\n\n加密逻辑 \n\n![image-20250915210647601](VMP_virtual_ISA/image-20250915210647601-1757941609480-11.png)\n\n**下面讲一下VMP中虚拟指令Handler的分类，并介绍了一部分比较重要的指令**\n\n# 1、元指令\n\n![image-20250915203613150](VMP_virtual_ISA/image-20250915203613150-1757939779361-1.png)\n\n来看一个具体的例子，vPushImm4，这是1.7Demo版本没有混淆的Handler实现：\n\n虚拟机栈顶Vesp就是ebp\n\n![img](VMP_virtual_ISA/1756368489674-fe27885a-0509-43d3-8907-b376c6c5a407-1757942882254-3-1757942884145-5.png)\n\n再来看一个虚拟寄存器入栈的指令：vPushReg4\n\n![img](VMP_virtual_ISA/1756368489882-34dea827-f9c2-4e73-a692-9a7114b76a71-1757942926985-9.png)\n\n# 2、算术运算指令\n\n![image-20250915213035826](VMP_virtual_ISA/image-20250915213035826-1757943038234-11.png)\n\n接下来我们来看一下算术运算指令。最经典的当属加法指令vAdd4：\n\n![img](VMP_virtual_ISA/1756368489824-3dfcb2ac-dfbd-4d3d-822d-00a6244fde4d-1757943069527-15.webp)\n\n这样一来，这条vAdd4虚拟指令执行完毕之后，栈顶第一个值就是最新的eflags，第二个值就是加法的和了。\n\n再来看一个逻辑右移指令vShr4:\n\n![img](VMP_virtual_ISA/1756368489817-62f9a6fe-a582-47ee-a2df-78dd33a8280e-1757943104403-19.webp)\n\n这个Handler中，从栈顶读取4个字节的被操作数放到eax寄存器，从栈顶+4的位置读取1个字节的移位计数放到cl寄存器。然后抬高栈顶2个字节，执行移位操作，把移位的结果放到新的栈顶+4的位置。最后和加法一样，移位操作同样会涉及eflags寄存器的修改，也要把最新的eflags保存到栈顶。\n\n这个图描绘了指令之前之前和执行完成的堆栈变化情况：\n\n![img](VMP_virtual_ISA/1756368490326-93177d5d-df6a-41ab-86e8-08308f1db22d-1757943125389-23.png)\n\n# 3、内存操作指令\n\n![image-20250915213319228](VMP_virtual_ISA/image-20250915213319228-1757943200606-29.png)\n\n接下来这一组是内存操作相关的虚拟指令，我们看一个例子vReadMemSs4：\n\n![img](VMP_virtual_ISA/1756368490620-f242fcf6-982d-4dd6-8d4c-efd93546c8a4-1757943183060-27.png)\n\n第一步：从堆栈顶部读取4个字节装入eax\n\n第二步：以刚刚读取到的eax的值作为指针，读取指向的内存区域，大小是4个字节，同样装入eax寄存器中。这里读取内存的时候，使用的段寄存器是ss，所以这个Handler命名里面有个Ss。\n\n**<font color='red'>vReadMemSs4相当于mov [ebp],[[ebp]]</font>**\n\n# 4、逻辑运算指令\n\n![image-20250915213525029](VMP_virtual_ISA/image-20250915213525029-1757943326896-31.png)\n\n![](VMP_virtual_ISA/image-20250915213551487-1757943354024-33.png)\n\n他的操作流程就是\n\n```c\nmov [ebp+4],and((not)[ebp],not([ebp+4]));\nmov [ebp],新的eflags;\n```\n\n# 5、跳转指令\n\n![](VMP_virtual_ISA/image-20250915213847338-1757943528887-35.png)\n\n直接从栈顶的位置取了4个字节赋值给了esi寄存器，然后ebp+4，更新栈顶指针位置就完成了。\n","tags":["VMP学习"]},{"title":"main函数回溯","url":"/2025/09/06/main_re/","content":"\n练习代码   工具：x32dbg \n\n```c\n#include<stdio.h>\n#include<stdlib.h>\nvoid Fun1(void)\n{\t\n}\nint main()\n{\n\tprintf(\"Fun1的地址 0x%x\", Fun1);\n\tFun1();\n\treturn 0;\n}\n```\n\nFun1的地址 0x2f1136\n\nctrl + g  0x2f1136  根据 [esp] 向上追一层 转到 0x002F18D8 \n\n![](main_re/1.png)\n\n定位到main 函数 0x002F18A0\n\n![](main_re/2.png)\n\nmain 函数处下断 根据esp 转上一层 0x002F2093\n\n![](main_re/3.png)\n\nmain函数在第4个call 被调用； 继续追 [esp]  = 0x002F1EE7（第4个函数是main）\n\n![](main_re/4.png)\n\n特征码 test  je 2个mov  push call add call  (invoke _main函数）\n\n![](main_re/5.png)\n\n![](main_re/6.png)\n\n向上追\n\n![](main_re/7.png)\n\n根据[esp] = 0x002F1D7D  反汇编转到   ,(_scrt_common_main_seh函数)\n\n![](main_re/8.png)\n\n向上追  [esp] = 0x002F2118\n\n![](main_re/9.png)\n\n转到上一层                    （_scrt_commom_main函数)\n\n![](main_re/10.png)\n\n结束了  [esp] 的值 是7 开头 ，这是内核的代码了 ，最后也就是追到_mainCRTstartup\n\n![](main_re/11.png)\n\n断点过程\n\n![](main_re/12.png)\n\n调用流程\n\n![](main_re/13.png)\n","tags":["汇编"]},{"title":"常见汇编2","url":"/2025/09/06/常见汇编2/","content":"\n## 多条件if跳转\n\n```c++\n\tint a = 0;\n\tif (a >= 0 && a != 3) {\n\t\tprintf(\"a is 0\\n\");\n\t}\n\telse if (a == 1) {\n\t\tprintf(\"a is 1\\n\");\n\t}\n\telse if (a >= 2 && a < 4) {\n\t\tprintf(\"a is 2\\n\");\n\t}\n\telse {\n\t\tprintf(\"error\\n\");\n\t}\t\n```\n\n```C++\n     5: \tint a = 0;\n00414565 C7 45 F8 00 00 00 00 mov         dword ptr [ebp-8],0  \n     6: \tif (a >= 0 && a != 3) {\n0041456C 83 7D F8 00          cmp         dword ptr [ebp-8],0  \n00414570 7C 15                jl          00414587  \n00414572 83 7D F8 03          cmp         dword ptr [ebp-8],3  \n00414576 74 0F                je          00414587  \n     7: \t\tprintf(\"a is 0\\n\");\n00414578 68 30 7B 41 00       push        417B30h  \n0041457D E8 4B CB FF FF       call        004110CD  \n00414582 83 C4 04             add         esp,4  \n     8: \t}\n00414585 EB 3D                jmp         004145C4  \n     9: \telse if (a == 1) {\n00414587 83 7D F8 01          cmp         dword ptr [ebp-8],1  \n0041458B 75 0F                jne         0041459C  \n    10: \t\tprintf(\"a is 1\\n\");\n0041458D 68 3C 7B 41 00       push        417B3Ch  \n00414592 E8 36 CB FF FF       call        004110CD  \n00414597 83 C4 04             add         esp,4  \n    11: \t}\n0041459A EB 28                jmp         004145C4  \n    12: \telse if (a >= 2 && a < 4) {\n0041459C 83 7D F8 02          cmp         dword ptr [ebp-8],2  \n004145A0 7C 15                jl          004145B7  \n004145A2 83 7D F8 04          cmp         dword ptr [ebp-8],4  \n004145A6 7D 0F                jge         004145B7  \n    13: \t\tprintf(\"a is 2\\n\");\n004145A8 68 48 7B 41 00       push        417B48h  \n004145AD E8 1B CB FF FF       call        004110CD  \n004145B2 83 C4 04             add         esp,4  \n    14: \t}\n004145B5 EB 0D                jmp         004145C4  \n    15: \telse {\n    16: \t\tprintf(\"error\\n\");\n004145B7 68 54 7B 41 00       push        417B54h  \n004145BC E8 0C CB FF FF       call        004110CD  \n004145C1 83 C4 04             add         esp,4  \n    17: \t}\n    18: }\n004145C4 5F                   pop         edi  \n```\n\n## 3目运算符\n\n```c++\nint a = 0;\nint b = 1;\nint c = 2;\nint d = a>b ? a : b;\n```\n\n```C++\n    21: \tint a = 0;\n00411FC5 C7 45 F8 00 00 00 00 mov         dword ptr [ebp-8],0  \n    22: \tint b = 1;\n00411FCC C7 45 EC 01 00 00 00 mov         dword ptr [ebp-14h],1  \n    23: \tint c = 2;\n00411FD3 C7 45 E0 02 00 00 00 mov         dword ptr [ebp-20h],2  \n    24: \tint d = a>b ? a : b;\n00411FDA 8B 45 F8             mov         eax,dword ptr [ebp-8]  \n00411FDD 3B 45 EC             cmp         eax,dword ptr [ebp-14h]  \n00411FE0 7E 0B                jle         00411FED  \n\n00411FE2 8B 4D F8             mov         ecx,dword ptr [ebp-8]  \n00411FE5 89 8D 0C FF FF FF    mov         dword ptr [ebp+FFFFFF0Ch],ecx\n\n00411FEB EB 09                jmp         00411FF6  \n00411F ED 8B 55 EC            mov         edx,dword ptr [ebp-14h]  \n00411FF0 89 95 0C FF FF FF    mov         dword ptr [ebp+FFFFFF0Ch],edx \n\n00411FF6 8B 85 0C FF FF FF    mov         eax,dword ptr [ebp+FFFFFF0Ch]  \n00411FFC 89 45 D4             mov         dword ptr [ebp-2Ch],eax  \n    25: \n    26: }\n```\n\n## switch case语句\n\n```C++\nint a = 1;\nswitch (a)\n{\ncase 1:\n\tprintf(\"a is 1\\n\");\n\tbreak;\ncase 2:\n\tprintf(\"a is 2\\n\");\n\tbreak;\ncase 3:\n\tprintf(\"a is 3\\n\");\n\tbreak;\ndefault:\n\tprintf(\"error\\n\");\n\tbreak;\n}\n```\n\n```C++\n    29: \tint a = 1;\n004118F5 C7 45 F8 01 00 00 00 mov         dword ptr [ebp-8],1  \n    30: \tswitch (a)\n004118FC 8B 45 F8             mov         eax,dword ptr [ebp-8]  \n004118FF 89 85 30 FF FF FF    mov         dword ptr [ebp+FFFFFF30h],eax\n\n00411905 83 BD 30 FF FF FF 01 cmp         dword ptr [ebp+FFFFFF30h],1  \n0041190C 74 14                je          00411922  \n0041190E 83 BD 30 FF FF FF 02 cmp         dword ptr [ebp+FFFFFF30h],2  \n00411915 74 1A                je          00411931  \n00411917 83 BD 30 FF FF FF 03 cmp         dword ptr [ebp+FFFFFF30h],3  \n0041191E 74 20                je          00411940  \n00411920 EB 2D                jmp         0041194F  \n    31: \t{\n    32: \tcase 1:\n    33: \t\tprintf(\"a is 1\\n\");\n00411922 68 3C 7B 41 00       push        417B3Ch  \n00411927 E8 A1 F7 FF FF       call        004110CD  \n0041192C 83 C4 04             add         esp,4  \n    34: \t\tbreak;\n0041192F EB 2B                jmp         0041195C  \n    35: \tcase 2:\n    36: \t\tprintf(\"a is 2\\n\");\n00411931 68 48 7B 41 00       push        417B48h  \n00411936 E8 92 F7 FF FF       call        004110CD  \n0041193B 83 C4 04             add         esp,4  \n    37: \t\tbreak;\n0041193E EB 1C                jmp         0041195C  \n    38: \tcase 3:\n    39: \t\tprintf(\"a is 3\\n\");\n00411940 68 5C 7B 41 00       push        417B5Ch  \n00411945 E8 83 F7 FF FF       call        004110CD  \n0041194A 83 C4 04             add         esp,4  \n    40: \t\tbreak;\n0041194D EB 0D                jmp         0041195C  \n    41: \tdefault:\n    42: \t\tprintf(\"error\\n\");\n0041194F 68 54 7B 41 00       push        417B54h  \n00411954 E8 74 F7 FF FF       call        004110CD  \n00411959 83 C4 04             add         esp,4  \n    43: \t\tbreak;\n    44: \t}\n    45: }\n0041195C 5F                   pop         edi  \n```\n\n**Tips**\n\n> 可以发现switch case和多条件if有异同\n>\n> 相同：都是 cmp je  ......  jmp 这种结构\n>\n> 不同：switch case  刚开始会出现  cmp je 多次重复的结构，if 判断条件如果有 && 这种也会出现，但是 if 的 后面的 je 跳转的地址都是相同的 ，但是switch 出现的 cmp je 的每个地址都是不相同的。 \n\n## switch case 跳转表（case >= 4个）\n\n```C++\nint a = 1;\n\tswitch (a)\n\t{\n\tcase 1:\n\t\tprintf(\"a is 1\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tprintf(\"a is 2\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tprintf(\"a is 3\\n\");\n\t\tbreak;\n\tcase 4:\n\t\tprintf(\"a is 4\\n\");\n\t\tbreak;\n\tcase 5:\n\t\tprintf(\"a is 5\\n\");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"error\\n\");\n\t\tbreak;\n\t}\n```\n\n```c++\n//int ntemp = 1\n004118E5 C7 45 F8 01 00 00 00 mov         dword ptr [ebp-8],1  \n\n//switchavr = ntemp\n004118EC 8B 45 F8             mov         eax,dword ptr [ebp-8]  \n004118EF 89 85 30 FF FF FF    mov         dword ptr [ebp+FFFFFF30h],eax\n\n//switchavr -= 1\n004118F5 8B 8D 30 FF FF FF    mov         ecx,dword ptr [ebp+FFFFFF30h]  \n004118FB 83 E9 01             sub         ecx,1                       //  add/sub ecx,|case(min)| \n004118FE 89 8D 30 FF FF FF    mov         dword ptr [ebp+FFFFFF30h],ecx  \n\n//比较switchavr和case(max)-1 \n00411904 83 BD 30 FF FF FF 04 cmp         dword ptr [ebp+FFFFFF30h],4   // 4 == case(max) +/-  |case(min)|\n0041190B 77 58                ja          00411965  \n\n0041190D 8B 95 30 FF FF FF    mov         edx,dword ptr [ebp+FFFFFF30h]  \n00411913 FF 24 95 88 19 41 00 jmp         dword ptr [edx*4+00411988h]  \n\n//跳转表\n0x00411988  1a 19 41 00\n0x0041198C  29 19 41 00\n0x00411990  38 19 41 00\n0x00411994  47 19 41 00\n0x00411998  56 19 41 00\n\n//case  1\n0041191A 68 3C 7B 41 00       push        417B3Ch  \n0041191F E8 A9 F7 FF FF       call        004110CD  \n00411924 83 C4 04             add         esp,4  \n00411927 EB 49                jmp         00411972  \n//case  2\n00411929 68 48 7B 41 00       push        417B48h  \n0041192E E8 9A F7 FF FF       call        004110CD  \n00411933 83 C4 04             add         esp,4  \n00411936 EB 3A                jmp         00411972  \n//case  3 \n00411938 68 5C 7B 41 00       push        417B5Ch  \n0041193D E8 8B F7 FF FF       call        004110CD  \n00411942 83 C4 04             add         esp,4  \n00411945 EB 2B                jmp         00411972  \n//case  4\n00411947 68 04 7C 41 00       push        417C04h  \n0041194C E8 7C F7 FF FF       call        004110CD  \n00411951 83 C4 04             add         esp,4  \n00411954 EB 1C                jmp         00411972  \n//case  5\n00411956 68 0C 7C 41 00       push        417C0Ch  \n0041195B E8 6D F7 FF FF       call        004110CD  \n00411960 83 C4 04             add         esp,4  \n00411963 EB 0D                jmp         00411972  \n//default\n00411965 68 54 7B 41 00       push        417B54h  \n0041196A E8 5E F7 FF FF       call        004110CD  \n0041196F 83 C4 04             add         esp,4  \n00411972 5F                   pop         edi  \n```\n\n## switch case 索引表\n\n```C++\n\tint a = 1;\n\tswitch (a)\n\t{\n\tcase 3:\n\t\tprintf(\"a is 2\\n\");\n\t\tbreak;\n\tcase 4:\n\t\tprintf(\"a is 3\\n\");\n\t\tbreak;\n\tcase 5:\n\t\tprintf(\"a is 4\\n\");\n\t\tbreak;\n\tcase 11:\n\t\tprintf(\"a is 5\\n\");\n\t\tbreak;\n\tcase 12:\n\t\tprintf(\"a is 6\\n\");\n\t\tbreak;\n\tcase 13:\n\t\tprintf(\"a is 7\\n\");\n\t\tbreak;\n\tcase 19:\n        printf(\"a is 8\\n\");\n\t\tbreak;\n\tcase 20:\n        printf(\"a is 10\\n\");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"error\\n\");\n\t\tbreak;\n\t}\n```\n\n```C++\n00415445 C7 45 F8 01 00 00 00 mov         dword ptr [ebp-8],1  \n0041544C 8B 45 F8             mov         eax,dword ptr [ebp-8]  \n0041544F 89 85 30 FF FF FF    mov         dword ptr [ebp+FFFFFF30h],eax  \n    \n00415455 8B 8D 30 FF FF FF    mov         ecx,dword ptr [ebp+FFFFFF30h]  \n0041545B 83 E9 03             sub         ecx,3  \n0041545E 89 8D 30 FF FF FF    mov         dword ptr [ebp+FFFFFF30h],ecx  \n\n00415464 83 BD 30 FF FF FF 11 cmp         dword ptr [ebp+FFFFFF30h],11h  \n0041546B 0F 87 8C 00 00 00    ja          004154FD  \n\n00415471 8B 95 30 FF FF FF    mov         edx,dword ptr [ebp+FFFFFF30h]  \n00415477 0F B6 82 44 55 41 00 movzx       eax,byte ptr [edx+00415544h]  \n\n//索引表\n0x00415544  00 01 02 08 08 08 08 08 \n0x0041554C  03 04 05 08 08 08 08 08  \n0x00415554  06 07 cc cc cc cc cc cc\n\n0041547E FF 24 85 20 55 41 00 jmp         dword ptr [eax*4+00415520h]  \n\n//跳转表\n0x00415520  85 54 41 00\n0x00415524  94 54 41 00  \n0x00415528  a3 54 41 00 \n0x0041552C  b2 54 41 00 \n0x00415530  c1 54 41 00 \n0x00415534  d0 54 41 00 \n0x00415538  df 54 41 00 \n0x0041553C  ee 54 41 00  \n0x00415540  fd 54 41 00\n\n//case 3\n00415485 68 48 7B 41 00       push        417B48h  \n0041548A E8 3E BC FF FF       call        004110CD  \n0041548F 83 C4 04             add         esp,4  \n00415492 EB 76                jmp         0041550A  \n//case 4\n00415494 68 5C 7B 41 00       push        417B5Ch  \n00415499 E8 2F BC FF FF       call        004110CD  \n0041549E 83 C4 04             add         esp,4  \n004154A1 EB 67                jmp         0041550A  \n//case 5\n004154A3 68 04 7C 41 00       push        417C04h  \n004154A8 E8 20 BC FF FF       call        004110CD  \n004154AD 83 C4 04             add         esp,4  \n004154B0 EB 58                jmp         0041550A\n//case 11  \n004154B2 68 0C 7C 41 00       push        417C0Ch  \n004154B7 E8 11 BC FF FF       call        004110CD  \n004154BC 83 C4 04             add         esp,4  \n004154BF EB 49                jmp         0041550A\n//case 12\n004154C1 68 14 7C 41 00       push        417C14h  \n004154C6 E8 02 BC FF FF       call        004110CD  \n004154CB 83 C4 04             add         esp,4  \n004154CE EB 3A                jmp         0041550A\n//case 13\n004154D0 68 1C 7C 41 00       push        417C1Ch  \n004154D5 E8 F3 BB FF FF       call        004110CD  \n004154DA 83 C4 04             add         esp,4  \n004154DD EB 2B                jmp         0041550A \n//case 19\n004154DF 68 08 7D 41 00       push        417D08h  \n004154E4 E8 E4 BB FF FF       call        004110CD  \n004154E9 83 C4 04             add         esp,4  \n004154EC EB 1C                jmp         0041550A\n//case 20\n004154EE 68 24 7D 41 00       push        417D24h  \n004154F3 E8 D5 BB FF FF       call        004110CD  \n004154F8 83 C4 04             add         esp,4  \n004154FB EB 0D                jmp         0041550A\n//default\n004154FD 68 54 7B 41 00       push        417B54h  \n00415502 E8 C6 BB FF FF       call        004110CD  \n00415507 83 C4 04             add         esp,4  \n0041550A 5F                   pop         edi   \n```\n\n## wile 循环\n\n```C++\n\tint a = 1;\n\twhile (a <= 10)\n\t{\n\t\ta++;\n\t}\n```\n\n```C++\n004119C5 C7 45 F8 01 00 00 00 mov         dword ptr [ebp-8],1  \n//  回到此处\n004119CC 83 7D F8 0A          cmp         dword ptr [ebp-8],0Ah  \n004119D0 7F 0B                jg          004119DD  \n004119D2 8B 45 F8             mov         eax,dword ptr [ebp-8]  \n004119D5 83 C0 01             add         eax,1  \n004119D8 89 45 F8             mov         dword ptr [ebp-8],eax  \n004119DB EB EF                jmp         004119CC  \n    \n004119DD 5F                   pop         edi  \n```\n\n## do while循环\n\n```c++\n\tint a = 1;\n\tdo {\n\t\tprintf(\"%d \\n\", a);\n\t\ta++;\n\t} while (a <= 10);\n```\n\n```C++\n00412195 C7 45 F8 01 00 00 00 mov         dword ptr [ebp-8],1  \n// 回到此外\n0041219C 8B 45 F8             mov         eax,dword ptr [ebp-8]  \n0041219F 50                   push        eax  \n004121A0 68 10 7D 41 00       push        417D10h  \n004121A5 E8 23 EF FF FF       call        004110CD  \n004121AA 83 C4 08             add         esp,8  \n004121AD 8B 45 F8             mov         eax,dword ptr [ebp-8]  \n004121B0 83 C0 01             add         eax,1  \n004121B3 89 45 F8             mov         dword ptr [ebp-8],eax  \n\n004121B6 83 7D F8 0A          cmp         dword ptr [ebp-8],0Ah  \n004121BA 7E E0                jle         0041219C  \n\n004121BC 5F                   pop         edi  \n```\n\n## for循环\n\n```C++\nfor (int a = 1; a <= 10; a++)\n{\n\tprintf(\"%d \\n\", a);\n}\n```\n\n```C++\n// int ntemp = 1\n004118E5 C7 45 F8 01 00 00 00 mov         dword ptr [ebp-8],1  \n004118EC EB 09                jmp         004118F7  \n//  a++\n004118EE 8B 45 F8             mov         eax,dword ptr [ebp-8]  \n004118F1 83 C0 01             add         eax,1\n004118F4 89 45 F8             mov         dword ptr [ebp-8],eax  \n//   a<=10\n004118F7 83 7D F8 0A          cmp         dword ptr [ebp-8],0Ah  \n004118FB 7F 13                jg          00411910  \n// 执行for内部代码\n004118FD 8B 45 F8             mov         eax,dword ptr [ebp-8]  \n00411900 50                   push        eax  \n00411901 68 10 7D 41 00       push        417D10h  \n00411906 E8 C2 F7 FF FF       call        004110CD  \n0041190B 83 C4 08             add         esp,8  \n0041190E EB DE                jmp         004118EE  \n\n00411910 5F                   pop         edi\n```\n\n","tags":["汇编"]},{"title":"远程线程注入","url":"/2024/11/01/远程线程注入/","tags":["hook"]},{"title":"IAT_hook","url":"/2024/10/31/IAT-hook/","content":"\n## 1.IAT hook原理：\n\nIAT（Import Address Table）Hook 的原理主要是通过修改可执行文件在运行时的导入地址表，以便拦截对特定函数的调用并将其重定向到自定义的函数。这种技术常用于实现日志记录、函数替换和监控等目的。\n\n### 原理步骤\n\n1. **了解 IAT**：\n   - 在 Windows PE 文件中，IAT 是用于存储程序所需的外部函数地址的表。每当程序调用某个外部函数时，它实际上是通过 IAT 查找该函数的地址。\n2. **获取 IAT 地址**：\n   - 程序加载时，操作系统会根据 PE 文件的导入表初始化 IAT。你可以通过解析 PE 文件结构，找到 IAT 的位置。\n3. **定位要 Hook 的函数**：\n   - 通过遍历 IAT，找到需要 Hook 的函数的地址。例如，可以通过函数名找到对应的函数地址。\n4. **修改 IAT 中的地址**：\n   - 将 IAT 中存储的函数地址替换为你自己的 Hook 函数的地址。这需要修改内存中的内容，因此通常需要更改内存保护属性（使用 `VirtualProtect` 函数）以允许写入。\n5. **实现 Hook 函数**：\n   - 创建一个自定义的 Hook 函数，该函数在被调用时可以执行自定义逻辑。通常，Hook 函数会调用原始函数，以保证程序的正常运行。\n6. **调用原始函数**：\n   - 在 Hook 函数中，如果需要，可以调用原始的被 Hook 函数，通常通过在 Hook 函数中保存原始函数的地址来实现。\n\n\n\n### 示例流程\n\n- 假设我们要 Hook `MessageBoxA` 函数：\n  1. 获取当前模块的 IAT 地址。\n  2. 遍历 IAT，找到 `MessageBoxA` 的地址。\n  3. 将 IAT 中的地址替换为自定义的 Hook 函数地址。\n  4. 自定义 Hook 函数可以在调用原始 `MessageBoxA` 之前或之后执行自定义逻辑。\n\n### 注意事项\n\n- **保护内存**：修改 IAT 时，必须确保适当地更改内存的保护属性，以允许写入。\n- **安全性**：Hook 技术可能被用于恶意目的，因此在使用时需要遵循相关法律法规。\n- **兼容性**：在不同的 Windows 版本和架构上，IAT Hook 的实现可能会有所不同。\n\n### 总结\n\nIAT Hook 是一种强大且灵活的技术，能够有效地拦截和重定向函数调用。理解其工作原理可以帮助开发者在进行系统监控、调试和逆向工程时更加得心应手。\n\n## 2.x64下的IAT hook实现\n\n> [!NOTE]\n>\n> 程序实现函数的时候都会使用call address ,实现函数的调用，如果我们hook 这个地址，就能调用我们的hook 函数，我们有知道PE文件的结构，所以可以在IAT实现目标函数的地址修改\n\n![](IAT-hook/1.png)\n\n**导入表的OriginalFirstThunK,FirstThunk分别指向INT和IAT**\n\n![](IAT-hook/2.png)\n\n*INT与IAT的每个条目都是一个4字节(32位下)的IMAGE_THUNK_DATA(它是一个union)*\n\n```C++\ntypedef union _IMAGE_THUNK_DATA {\n    ULONG ForwarderString; // 指向转发字符串的指针\n    ULONG Function;        // 指向导入函数的地址\n    ULONG Ordinal;         // 函数的序号\n    PIMAGE_IMPORT_BY_NAME AddressOfData; // 指向名称和序号的结构\n} IMAGE_THUNK_DATA;\n```\n\n**接下是实例:使用IAT hook 系统函数MessageBoxW**\n\n```C++\n#include <Windows.h>\n#include <iostream>\n// 保存原先函数地址\ntypedef int (WINAPI* MessageBoxW_t)(HWND, LPCWSTR, LPCWSTR, UINT);\nMessageBoxW_t OriginalMessageBoxW = nullptr;\n\nint WINAPI HookMessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType) {\n    // 调用原先函数\n    return OriginalMessageBoxW(hWnd, L\"IAT HOOK success!\", lpCaption, uType);\n}\n\nbool InstallIATHook(const char* dllName, const char* funName, void* hookFuncAddr) {\n    HMODULE hModule = GetModuleHandleA(NULL);\n    \n    if (!hModule) return false;\n\t// 注意都是RVA地址,所以计算地址时要加上基址\n    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)hModule;\n    // NT 头\n    PIMAGE_NT_HEADERS64 ntHeaders = (PIMAGE_NT_HEADERS64)((BYTE*)dosHeader + dosHeader->e_lfanew);\n    // 可选头\n    PIMAGE_OPTIONAL_HEADER64 optionalHeader = &ntHeaders->OptionalHeader;\n    IMAGE_DATA_DIRECTORY directory = optionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];\n    PIMAGE_IMPORT_DESCRIPTOR importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE*)hModule + directory.VirtualAddress);\n\n    while (importDescriptor->Name) {\n        const char* iatDllName = (const char*)((BYTE*)hModule + importDescriptor->Name);\n        if (_stricmp(dllName, iatDllName) == 0) {\n            PIMAGE_THUNK_DATA64 pInt = (PIMAGE_THUNK_DATA64)((BYTE*)hModule + importDescriptor->OriginalFirstThunk);\n            PIMAGE_THUNK_DATA64 pIat = (PIMAGE_THUNK_DATA64)((BYTE*)hModule + importDescriptor->FirstThunk);\n\n            while (pInt->u1.AddressOfData) {\n                PIMAGE_IMPORT_BY_NAME pImportByName = (PIMAGE_IMPORT_BY_NAME)((BYTE*)hModule + pInt->u1.AddressOfData);\n                if (strcmp((const char*)pImportByName->Name, funName) == 0) {\n                    // 保存原始地址\n                    OriginalMessageBoxW = (MessageBoxW_t)pIat->u1.Function;\n\n                    DWORD oldProtect;\n                    VirtualProtect(&pIat->u1.Function, sizeof(void*), PAGE_EXECUTE_READWRITE, &oldProtect);\n                    pIat->u1.Function = (DWORD_PTR)hookFuncAddr;\n                    VirtualProtect(&pIat->u1.Function, sizeof(void*), oldProtect, &oldProtect);\n\n                    return true;\n                }\n                pInt++;\n                pIat++;\n            }\n        }\n        importDescriptor++;\n    }\n    return false;\n}\n\nint main() {\n    InstallIATHook(\"user32.dll\", \"MessageBoxW\", HookMessageBoxW);\n    MessageBoxW(NULL, L\"hello,world\", L\"@Xhani\", MB_OK);\n    return 0;\n}\n```\n\n![](IAT-hook/3.png)\n\n###### ***Todo1:请编程实现HOOK WriteFile 这个Windows API，实现每次调用这个函数的时候，在写入的数据后面增加一个字符串:Xhani!!!。然后程序里尝试打开一个文件，并写入一些数据，最后打开文件看看是否有这个字符串内容。***\n\n```C++\n#include <windows.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef BOOL(WINAPI* HWriteFile)(_In_ HANDLE hFile,\n    _In_reads_bytes_opt_(nNumberOfBytesToWrite) LPCVOID lpBuffer,\n    _In_ DWORD nNumberOfBytesToWrite,\n    _Out_opt_ LPDWORD lpNumberOfBytesWritten,\n    _Inout_opt_ LPOVERLAPPED lpOverlapped);\n\nHWriteFile targetaddress = nullptr;\n\nBOOL HookWriteFile(\n    _In_ HANDLE hFile,\n    _In_reads_bytes_opt_(nNumberOfBytesToWrite) LPCVOID lpBuffer,\n    _In_ DWORD nNumberOfBytesToWrite,\n    _Out_opt_ LPDWORD lpNumberOfBytesWritten,\n    _Inout_opt_ LPOVERLAPPED lpOverlapped\n) {\n    char str[] = \"Xhani!!!\";\n    size_t len = strlen(str) + nNumberOfBytesToWrite;\n    char* buffer = (char*)malloc(len + 1);\n    if (buffer == NULL) return FALSE;\n\n    memcpy(buffer, lpBuffer, nNumberOfBytesToWrite);\n    memcpy(buffer + nNumberOfBytesToWrite, str, strlen(str) + 1); // 修改为+1，正确拼接\n\n    BOOL result = targetaddress(hFile, buffer, len, lpNumberOfBytesWritten, lpOverlapped);\n    free(buffer); // 释放内存\n    return result;\n}\n\nBOOL iathookWriteFile(const char* dllname, const char* function, void* hookaddress) {\n    HMODULE hmodule = GetModuleHandle(NULL);\n    PIMAGE_DOS_HEADER pDosheader = (PIMAGE_DOS_HEADER)hmodule;\n    PIMAGE_NT_HEADERS64 pNtheader = (PIMAGE_NT_HEADERS64)(pDosheader->e_lfanew + (BYTE*)hmodule);\n    PIMAGE_OPTIONAL_HEADER64 pOptionhead = &pNtheader->OptionalHeader;\n    IMAGE_DATA_DIRECTORY directory = pOptionhead->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];\n    PIMAGE_IMPORT_DESCRIPTOR importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE*)hmodule + directory.VirtualAddress);\n\n    while (importDescriptor->Name) {\n        const char* iatdllname = (const char*)((BYTE*)hmodule + importDescriptor->Name);\n        if (_stricmp(iatdllname, dllname) == 0) {\n            PIMAGE_THUNK_DATA64 pInt = (PIMAGE_THUNK_DATA64)((BYTE*)hmodule + importDescriptor->OriginalFirstThunk);\n            PIMAGE_THUNK_DATA64 pIat = (PIMAGE_THUNK_DATA64)((BYTE*)hmodule + importDescriptor->FirstThunk);\n            while (pInt->u1.AddressOfData) {\n                PIMAGE_IMPORT_BY_NAME pImportByName = (PIMAGE_IMPORT_BY_NAME)((BYTE*)hmodule + pInt->u1.AddressOfData);\n                if (_stricmp((const char*)pImportByName->Name, function) == 0) {\n                    // 保存原始地址\n                    targetaddress = (HWriteFile)pIat->u1.Function;\n\n                    DWORD oldProtect;\n                    VirtualProtect(&pIat->u1.Function, sizeof(void*), PAGE_EXECUTE_READWRITE, &oldProtect);\n                    pIat->u1.Function = (DWORD_PTR)hookaddress;\n                    VirtualProtect(&pIat->u1.Function, sizeof(void*), oldProtect, &oldProtect);\n\n                    return true;\n                }\n                pInt++;\n                pIat++;\n            }\n            importDescriptor++;\n        }\n        return FALSE;\n    }\n}\n\nint main() {\n    HANDLE hFile = ::CreateFile(\"exp.txt\", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n    if (hFile == INVALID_HANDLE_VALUE) {\n        printf(\"Failed to create file.\\n\");\n        return 1; // 处理错误\n    }\n    char str[] = \"hello_world\";\n    DWORD byteswriten;\n    if (iathookWriteFile(\"KERNEL32.dll\", \"WriteFile\", HookWriteFile)) {\n        WriteFile(hFile, str, strlen(str), &byteswriten, NULL);\n    }\n    else {\n        printf(\"Failed to hook WriteFile.\\n\");\n    }\n    return 0;\n}\n```\n\n","tags":["hook"]},{"title":"PE文件学习","url":"/2024/10/30/PE文件学习/","content":"\n## PE 文件的学习：\n\n### 1.了解\n\nPE（ Portable Execute）文件是Windows下可执行文件的总称，常见的有 **DLL，EXE，OCX，SYS** 等。它是微软在 UNIX 平台的 COFF（通用对象文件格式）基础上制作而成。**最初设计用来提高程序在不同操作系统上的移植性，但实际上这种文件格式仅用在 Windows 系列操作系统下**。**PE文件是指 32 位可执行文件，也称为PE32。64位的可执行文件称为 PE+ 或 PE32+，是PE(PE32)的一种扩展形式（请注意不是PE64)**。\n\n事实上，**一个文件是否是 PE 文件与其扩展名无关**，PE文件可以是任何扩展名。那 Windows 是怎么区分可执行文件和非可执行文件的呢？我们调用 LoadLibrary 传递了一个文件名，**系统是如何判断这个文件是一个合法的动态库呢？这就涉及到PE文件结构了。**\n\n![](PE文件学习/2.png)\n\n### 2.结构学习\n\n### 一、DOS头\n\nDOS头 的作用是兼容 MS-DOS 操作系统中的可执行文件，对于 32位PE文件来说，DOS 所起的作用就是显示一行文字，提示用户：我需要在32位windows上才可以运行。我认为这是个善意的玩笑，因为他并不像显示的那样不能运行，其实已经运行了，只是在 DOS 上没有干用户希望看到的工作而已，好吧，我承认这不是重点。但是，至少我们看一下这个头是如何定义的：\n\n```c\ntypedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header\n    WORD   e_magic;                     // Magic number\n    WORD   e_cblp;                      // Bytes on last page of file\n    WORD   e_cp;                        // Pages in file\n    WORD   e_crlc;                      // Relocations\n    WORD   e_cparhdr;                   // Size of header in paragraphs\n    WORD   e_minalloc;                  // Minimum extra paragraphs needed\n    WORD   e_maxalloc;                  // Maximum extra paragraphs needed\n    WORD   e_ss;                        // Initial (relative) SS value\n    WORD   e_sp;                        // Initial SP value\n    WORD   e_csum;                      // Checksum\n    WORD   e_ip;                        // Initial IP value\n    WORD   e_cs;                        // Initial (relative) CS value\n    WORD   e_lfarlc;                    // File address of relocation table\n    WORD   e_ovno;                      // Overlay number\n    WORD   e_res[4];                    // Reserved words\n    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)\n    WORD   e_oeminfo;                   // OEM information; e_oemid specific\n    WORD   e_res2[10];                  // Reserved words\n    LONG   e_lfanew;                    // File address of new exe header\n  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;\n```\n\n![](PE文件学习/1.png)\n\n### 二、NT头\n\n顺着 DOS 头中的 **e_lfanew**，我们很容易可以找到 **NT头，这个才是 32位PE文件中最有用的头**，定义如下:\n\n```C\ntypedef struct _IMAGE_NT_HEADERS {\n    DWORD Signature;\n    IMAGE_FILE_HEADER FileHeader;\n    IMAGE_OPTIONAL_HEADER32 OptionalHeader;\n} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;\n```\n\n##### 1.Signature\n\n类似于 DOS头中的 e_magic，其高16位是0，低16是0x4550，用字符表示是 'PE‘ 。⭐⭐⭐\n\n##### 2.IMAGE_FILE_HEADER(文件头)\n\n```c\ntypedef struct _IMAGE_FILE_HEADER {\n    WORD    Machine;\n    WORD    NumberOfSections;⭐⭐⭐\n    DWORD   TimeDateStamp;\n    DWORD   PointerToSymbolTable;\n    DWORD   NumberOfSymbols;\n    WORD    SizeOfOptionalHeader;\n    WORD    Characteristics;\n} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;\n```\n\nMachine：该文件的运行平台，是 x86、x64 还是 I64 等等；\n\n<u>NumberOfSections：   该PE文件中有多少个节，也就是节表中的项数。</u>\nTimeDateStamp：      PE文件的创建时间，一般有连接器填写。\nPointerToSymbolTable： COFF文件符号表在文件中的偏移。\nNumberOfSymbols：    符号表的数量。\nSizeOfOptionalHeader： 紧随其后的可选头的大小。\nCharacteristics：       可执行文件的属性\n\n##### 3.IMAGE_OPTIONAL_HEADER(可选头)\n\n***别看他名字叫可选头，其实一点都不能少，不过，它在不同的平台下是不一样的，例如32位下是IMAGE_OPTIONAL_HEADER32，而在64位下是IMAGE_OPTIONAL_HEADER64。为了简单起见，我们只看32位。***\n\n```C\ntypedef struct _IMAGE_OPTIONAL_HEADER {\n    WORD    Magic;\n    BYTE    MajorLinkerVersion;\n    BYTE    MinorLinkerVersion;\n    DWORD   SizeOfCode;\n    DWORD   SizeOfInitializedData;\n    DWORD   SizeOfUninitializedData;\n    DWORD   AddressOfEntryPoint;\n    DWORD   BaseOfCode;\n    DWORD   BaseOfData;\n    DWORD   ImageBase;\n    DWORD   SectionAlignment;  ⭐⭐⭐\n    DWORD   FileAlignment;  ⭐⭐⭐\n    WORD    MajorOperatingSystemVersion;\n    WORD    MinorOperatingSystemVersion;\n    WORD    MajorImageVersion;\n    WORD    MinorImageVersion;\n    WORD    MajorSubsystemVersion;\n    WORD    MinorSubsystemVersion;\n    DWORD   Win32VersionValue;\n    DWORD   SizeOfImage;\n    DWORD   SizeOfHeaders;\n    DWORD   CheckSum;\n    WORD    Subsystem;\n    WORD    DllCharacteristics;\n    DWORD   SizeOfStackReserve;\n    DWORD   SizeOfStackCommit;\n    DWORD   SizeOfHeapReserve;\n    DWORD   SizeOfHeapCommit;\n    DWORD   LoaderFlags;\n    DWORD   NumberOfRvaAndSizes;\n    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];\n} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;\n```\n\n- **Magic**：表示可选头的类型。\n\n  ```C\n  #define IMAGE_NT_OPTIONAL_HDR32_MAGIC      0x10b  // 32位PE可选头\n  #define IMAGE_NT_OPTIONAL_HDR64_MAGIC      0x20b  // 64位PE可选头\n  #define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107  \n  ```\n\n  \n\n- **MajorLinkerVersion** 和 **MinorLinkerVersion**：链接器的版本号。\n\n- **SizeOfCode**：代码段的长度，如果有多个代码段，则是代码段长度的总和。\n\n- **SizeOfInitializedData**：初始化的数据长度。\n\n- **SizeOfUninitializedData**：未初始化的数据长度。\n\n- **AddressOfEntryPoint：程序入口的 RVA，对于exe这个地址可以理解为WinMain的RVA。对于DLL，这个地址可以理解为DllMain的RVA，如果是驱动程序，可以理解为DriverEntry的RVA。当然，实际上入口点并非是WinMain，DllMain和DriverEntry，在这些函数之前还有一系列初始化要完成，当然，这些不是本文的重点。**⭐⭐⭐\n\n- **BaseOfCode**：代码段起始地址的RVA。\n\n- **BaseOfData**：数据段起始地址的RVA。\n\n- **ImageBase**：映象（加载到内存中的PE文件）的基地址，这个基地址是建议，对于DLL来说，如果无法加载到这个地址，系统会自动为其选择地址。⭐⭐⭐\n\n- **SectionAlignment**：节对齐，PE中的节被加载到内存时会按照这个域指定的值来对齐，比如这个值是0x1000，那么每个节的起始地址的低12位都为0。⭐⭐⭐\n\n- **FileAlignment**：节在文件中按此值对齐，SectionAlignment必须大于或等于FileAlignment。\n\n- **MajorOperatingSystemVersion**、MinorOperatingSystemVersion：所需操作系统的版本号，随着操作系统版本越来越多，这个好像不是那么重要了。\n\n- **MajorImageVersion**、**MinorImageVersion**：映象的版本号，这个是开发者自己指定的，由连接器填写。\n\n- **MajorSubsystemVersion**、**MinorSubsystemVersion**：所需子系统版本号。\n\n- **Win32VersionValue**：保留，必须为0。\n\n- **SizeOfImage**：映象的大小，PE文件加载到内存中空间是连续的，这个值指定占用虚拟空间的大小。\n\n- **SizeOfHeaders**：所有文件头（包括节表）的大小，这个值是以FileAlignment对齐的。\n\n- **CheckSum**：映象文件的校验和。\n\n- **Subsystem**：运行该PE文件所需的子系统。\n\n- **SizeOfStackReserve**：运行时为每个线程栈保留内存的大小。\n\n- **SizeOfStackCommit**：运行时每个线程栈初始占用内存大小。\n\n- **SizeOfHeapReserve**：运行时为进程堆保留内存大小。\n\n- **SizeOfHeapCommit**：运行时进程堆初始占用内存大小。\n\n- **LoaderFlags**：保留，必须为0。\n\n- **NumberOfRvaAndSizes**：数据目录的项数，即下面这个数组的项数。\n\n- ⭐⭐⭐⭐⭐**DataDirectory**：数据目录，这是一个数组，数组的项定义如下：\n\n  ```C\n  typedef struct _IMAGE_DATA_DIRECTORY {\n      DWORD   VirtualAddress; //是一个RVA的偏移地址\n      DWORD   Size; // 对应表的大小\n  } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;\n  ```\n\n  这两个数有什么用呢 ？**一个是地址，一个是大小，可以看出这个数据目录项定义的是一个区域**。**那他定义的是什么东西的区域呢？**前面说了，**DataDirectory 是个数组**，**数组中的每一项对应一个特定的数据结构**，**包括导入表，导出表等等**，**根据不同的索引取出来的是不同的结构**，头文件里定义各个项表示哪个结构，如下面的代码所示:\n\n```C\n#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory ⭐⭐⭐   \n#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory  ⭐⭐⭐\n#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory\n#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory\n#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory\n#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table\n#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory\n//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)\n#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data\n#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP\n#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory   ⭐⭐\n#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory\n#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers\n#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table  ⭐⭐  //IAT\n#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors\n#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor\n```\n\n### 三.IMAGE_SECTION_HEADER（节表）\n\n```C\ntypedef struct _IMAGE_SECTION_HEADER {\n    Name\t\t\t\t\t\t//8个字节的块名\n    union\t\t\t\t\t\t\n    {\n        DWORD PhysicalAddress;\n        DWORD VirtualSize;\n    } Misc;                     //区块尺寸\n    DWORD VirtualAddress;\t\t//区块的RVA地址\n    DWORD SizeOfRawData;\t\t//在文件中对齐后的尺寸\n    DWORD PointerToRawData;\t\t//在文件中偏移\n    DWORD PointerToRelocations;\t//在OBJ文件中使用，重定位的偏移\n    DWORD PointerToLinenumbers;\t//行号表的偏移（供调试使用地）\n    WORD NumberOfRelocations;\t//在OBJ文件中使用，重定位项数目\n    WORD NumberOfLinenumbers;\t//行号表中行号的数目\n    DWORD Characteristics;\t\t//区块属性如可读，可写，可执行等\n} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;\n```\n\n### 四.节\n\n每个区块的名称都是唯一的，不能有同名的两个区块。\n但事实上节的名称不表示任何含义，他的存在仅仅是为了正规统一编程的时候方便程序员查看方便而设置的一个标记而已。所以将包含代码的区块命名为“.Data” （一般为.text）或者说将包含数据的区块命名为“.Code”（一般为.rdata等） 都是合法的。\n当我们要从PE 文件中读取需要的区块的时候，不能以区块的名称作为定位的标准和依据，正确方法是\n\n在节头（`IMAGE_SECTION_HEADER`）中。要定位节的地址，你可以按照以下步骤进行：\n\n1. **获取文件头**：从 PE 文件的起始部分读取 DOS 头（`IMAGE_DOS_HEADER`），然后找到 PE 头的位置。\n2. **读取可选头**：从 PE 头中读取可选头（`IMAGE_OPTIONAL_HEADER32`），确认文件类型（如 PE32）。\n3. **读取节表**：可选头后面会跟着一个或多个节头。节头的数量在可选头中指定，通常可以通过 `NumberOfSections` 字段获取。\n4. **计算节的地址**：每个节头都有一个 `VirtualAddress` 字段，表示该节在内存中的地址。你可以通过遍历节头来查找特定节的信息。\n5. **加载地址**：当 PE 文件被加载到内存中时，你可以将 `VirtualAddress` 和基址相加，以确定节的实际内存地址。\n\n各种节的描述：\n\n![](PE文件学习/3.png)\n\n### 五.其他注意\n\n##### 1.RVA 和文件偏移换算\n\n在 PE 文件格式中，RVA（Relative Virtual Address）和文件偏移之间的换算是非常重要的。以下是相关术语和它们在 PE 文件结构中的定义，以及如何进行换算的方法：\n\n### 术语及其定义\n\n1. **RVA（Relative Virtual Address）**：\n   - **定义**：相对虚拟地址，是指某个节或数据在内存中的相对地址，通常是相对于加载基址（`ImageBase`）的偏移。\n   - **结构**：在 `IMAGE_SECTION_HEADER` 中的 `VirtualAddress` 字段。\n\n2. **FOA（File Offset Address）**：\n   - **定义**：文件偏移地址，指的是文件中某个特定数据或结构的偏移位置。\n   - **结构**：在 `IMAGE_SECTION_HEADER` 中的 `PointerToRawData` 字段。\n\n3. **ImageBase**：\n   - **定义**：基址，指 PE 文件在内存中加载时的起始地址。\n   - **结构**：在 `IMAGE_OPTIONAL_HEADER` 中的 `ImageBase` 字段。\n\n### RVA 与 FOA 之间的换算\n\n#### 1. 从 RVA 转换到 FOA\n\n给定一个 RVA，可以使用以下公式转换为 FOA：\n\n```\nFOA = RVA - Section.VirtualAddress + Section.PointerToRawData\n```\n\n- **解释**：\n  - `Section.VirtualAddress`：对应节头中的 `VirtualAddress` 字段。\n  - `Section.PointerToRawData`：对应节头中的 `PointerToRawData` 字段。\n  \n#### 2. 从 FOA 转换到 RVA\n\n给定一个 FOA，可以使用以下公式转换为 RVA：\n\n```\nRVA = FOA - Section.PointerToRawData + Section.VirtualAddress\n```\n\n### 示例\n\n假设有以下节头信息：\n\n- **节名**：`.text`\n- **VirtualAddress**：`0x1000`\n- **PointerToRawData**：`0x200`\n\n那么，对于某个特定的 RVA `0x1010`，可以计算 FOA 如下：\n\n```\nFOA = 0x1010 - 0x1000 + 0x200 = 0x210\n```\n\n如果要将 FOA `0x210` 转换回 RVA：\n\n```\nRVA = 0x210 - 0x200 + 0x1000 = 0x1010\n```\n\n### 总结\n\n- **RVA** 是节在内存中的相对虚拟地址。\n- **FOA** 是节在文件中的具体偏移。\n- 使用 `IMAGE_SECTION_HEADER` 中的 `VirtualAddress` 和 `PointerToRawData` 字段进行 RVA 和 FOA 之间的换算。\n\n这些计算在 PE 文件的解析、调试和分析中是非常重要的，理解这些术语及其对应的结构定义将有助于处理 PE 文件格式。\n\n\n\n**<u>同时计算时也要考虑对齐会对RVA 与 FOA 之间的换算影响</u>**\n\n节对齐和文件对齐是 PE 文件格式中两个重要的概念，它们的主要区别如下：\n\n### 节对齐（Section Alignment）\n\n1. **定义**：\n   - 节对齐是指在 PE 文件加载到内存中时，节在内存中的对齐要求。它决定了每个节的起始地址必须是某个特定值的倍数。\n\n2. **位置**：\n   - 节对齐的值在 `IMAGE_OPTIONAL_HEADER` 结构中，字段名称为 `SectionAlignment`。\n\n3. **作用**：\n   - 确保加载到内存中的节按页对齐，以优化内存访问和提高性能。通常，`SectionAlignment` 的值为 4096 字节（一个内存页的大小）。\n\n4. **加载时的对齐**：\n   - 节对齐是在 PE 文件加载到内存后生效的。加载过程会根据 `SectionAlignment` 进行调整。\n\n### 文件对齐（File Alignment）\n\n1. **定义**：\n   - 文件对齐是指在 PE 文件中，节在文件中的对齐要求。它决定了每个节在文件中开始的位置必须是某个特定值的倍数。\n\n2. **位置**：\n   - 文件对齐的值同样在 `IMAGE_OPTIONAL_HEADER` 结构中，字段名称为 `FileAlignment`。\n\n3. **作用**：\n   - 确保在 PE 文件中，节的起始位置按照 `FileAlignment` 对齐，以便于文件的读取和解析。通常，`FileAlignment` 的值为 512 字节或 4096 字节。\n\n4. **未加载时的对齐**：\n   - 文件对齐是在 PE 文件未加载时适用的。它影响文件的存储格式，而不是内存中的布局。\n\n### 总结\n\n- **节对齐**：适用于 PE 文件加载到内存后的内存布局，确保节按页对齐。\n- **文件对齐**：适用于 PE 文件的存储格式，确保节在文件中按字节对齐。\n\n因此，节对齐和文件对齐是针对不同上下文的对齐要求，它们的值和作用有所不同。\n\n#### 2.PE文件与内存映射\n\n**就是把** **PE 文件** **从** **硬盘中** **放到** **内存中****，然后 CPU 从 内存中读取指令并执行。\n\n![](PE文件学习/a.png)\n\n![](PE文件学习/7.png)\n\n**文件中使用偏移（offset），内存中使用 VA（Virtual Address，虚拟地址）来表示位置。**\n\n**VA 指进程虚拟内存的绝对地址**，**RVA(Relative Virtual Address，相对虚拟地址)是指从某基准位置（ImageBase）开始的相对地址**。VA 与 RVA 满足下面的换算关系： **RVA + ImageBase = VA**\n\n***************************************************************\nPE 头内部信息大多是 RVA 形式存在。\n原因在于（主要是DLL）加载到进程虚拟内存的特定位置时，该位置可能已经加载了其他的 PE文件（DLL）。\n此时必须通过重定向（Relocation）将其加载到其他空白的位置，若 PE头信息使用的是 VA，则无法正常访问。\n因此使用 RVA 来重定向信息，即使发生了重定向，只要相对于基准位置的相对位置没有变化，就能正常访问到指定信息，不会出现任何问题。\n***************************************************************\n\n**当 PE 文件被执行时，PE 装载器会为 \\**进程\\** 分配 4GB 的 \\**虚拟地址空间\\**\\**（ Virtual address spaces 官方文档：\\**\\**https://docs.microsoft.com/zh-tw/windows-hardware/drivers/gettingstarted/virtual-address-spaces\\** \\**）\\**，然后把程序所占用的磁盘空间作为虚拟内存映射到这个4GB的虚拟地址空间中。一般情况下，会映射到 \\**虚拟地址空间\\** 中的 0X400000的位置。**\n\n![](PE文件学习/f.png)\n\n### Last\n\n写的PE文件分析器🌃🌃🌃\n\n```C++\n#include <iostream>\n#include <fstream>\n#include <windows.h>\n\nusing namespace std;\n\nvoid PrintDataDirectory(IMAGE_DATA_DIRECTORY dir, const char* name) {\n    cout << name << \" - RVA: 0x\" << hex << dir.VirtualAddress << \", Size: 0x\" << dir.Size << dec << endl;\n}\n\nvoid ParsePEFile(const char* filePath) {\n    // 打开文件\n    ifstream file(filePath, ios::binary | ios::in);\n    if (!file) {\n        cerr << \"无法打开文件: \" << filePath << endl;\n        return;\n    }\n\n    // 读取DOS头\n    IMAGE_DOS_HEADER dosHeader;\n    file.read(reinterpret_cast<char*>(&dosHeader), sizeof(IMAGE_DOS_HEADER));\n    if (dosHeader.e_magic != IMAGE_DOS_SIGNATURE) {\n        cerr << \"不是有效的PE文件\" << endl;\n        return;\n    }\n\n    // 跳转到PE头\n    file.seekg(dosHeader.e_lfanew, ios::beg);\n    DWORD signature;\n    file.read(reinterpret_cast<char*>(&signature), sizeof(DWORD));\n\n    if (signature != IMAGE_NT_SIGNATURE) {\n        cerr << \"PE签名无效\" << endl;\n        return;\n    }\n\n    // 读取文件头\n    IMAGE_FILE_HEADER fileHeader;\n    file.read(reinterpret_cast<char*>(&fileHeader), sizeof(IMAGE_FILE_HEADER));\n\n    // 读取可选头（32位/64位）\n    IMAGE_OPTIONAL_HEADER optionalHeader;\n    file.read(reinterpret_cast<char*>(&optionalHeader), sizeof(IMAGE_OPTIONAL_HEADER));\n\n    cout << \"PE文件解析：\" << filePath << endl;\n    cout << \"-----------------------------------\" << endl;\n\n    // 输出加载基地址、入口地址\n    cout << \"加载基地址: 0x\" << hex << optionalHeader.ImageBase << endl;\n    cout << \"入口地址: 0x\" << hex << optionalHeader.AddressOfEntryPoint << endl;\n\n    // 判断是否启用了DEP、ASLR、控制流保护、SEH\n    bool depEnabled = (optionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NX_COMPAT);\n    bool aslrEnabled = (optionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE);\n    bool cfGuardEnabled = (optionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_GUARD_CF);\n    bool sehEnabled = !(fileHeader.Characteristics & IMAGE_FILE_DLL); // SEH一般禁用DLL\n\n    cout << \"DEP启用: \" << (depEnabled ? \"是\" : \"否\") << endl;\n    cout << \"ASLR启用: \" << (aslrEnabled ? \"是\" : \"否\") << endl;\n    cout << \"控制流保护启用: \" << (cfGuardEnabled ? \"是\" : \"否\") << endl;\n    cout << \"SEH启用: \" << (sehEnabled ? \"是\" : \"否\") << endl;\n\n    // 输出数据目录项信息\n    cout << \"-----------------------------------\" << endl;\n    cout << \"数据目录项:\" << endl;\n\n    PrintDataDirectory(optionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT], \"Export Table\");\n    PrintDataDirectory(optionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT], \"Import Table\");\n    PrintDataDirectory(optionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE], \"Resource Table\");\n    PrintDataDirectory(optionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION], \"Exception Table\");\n    PrintDataDirectory(optionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY], \"Security Table\");\n    PrintDataDirectory(optionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC], \"Base Relocation Table\");\n    PrintDataDirectory(optionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG], \"Debug Directory\");\n    PrintDataDirectory(optionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS], \"TLS Table\");\n\n    // 输出所有节的名字、相对偏移、大小\n    cout << \"-----------------------------------\" << endl;\n    cout << \"节信息:\" << endl;\n\n    file.seekg(dosHeader.e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + fileHeader.SizeOfOptionalHeader, ios::beg);\n    IMAGE_SECTION_HEADER sectionHeader;\n    for (int i = 0; i < fileHeader.NumberOfSections; i++) {\n        file.read(reinterpret_cast<char*>(&sectionHeader), sizeof(IMAGE_SECTION_HEADER));\n        cout << \"节名: \" << string(reinterpret_cast<char*>(sectionHeader.Name), 8) << endl;\n        cout << \"相对虚拟地址: 0x\" << hex << sectionHeader.VirtualAddress << endl;\n        cout << \"大小: 0x\" << hex << sectionHeader.Misc.VirtualSize << dec << endl;\n        cout << \"-----------------------------------\" << endl;\n    }\n\n    file.close();\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        cerr << \"用法: \" << argv[0] << \" <PE文件路径>\" << endl;\n        return 1;\n    }\n    ParsePEFile(argv[1]);\n    return 0;\n}\n\n```\n\n```\n使用命令:./pe.exe target.exe\n```\n\n","tags":["PE"]},{"title":"Inline_hook","url":"/2024/10/29/Inline-hook/","content":"\n> [!IMPORTANT]\n>\n> inline_hook 一般的想法就是替换某个函数的第1个汇编命令 改成 jmp 目标函数的想法\n>\n> 另外需要注意的是      hook 函数与被hook处的函数 的 调用类型 要相同\n\n## 1.x86 下的Inline hook\n\nx86 下 一般都是使用jmp 指令  ： 5个字节 （0xE9 ** ** ** ** ) 后面四个字节就是偏移地址\n\n```c++\n#include<stdio.h>\n#include<Windows.h>\nint WINAPI hookMessageBox(\n    _In_opt_ HWND hWnd,\n    _In_opt_ LPCWSTR lpText,\n    _In_opt_ LPCWSTR lpCaption,\n    _In_ UINT uType)\n{\n    printf(\"%s;%s\\n\", lpText, lpCaption);\n    return 0;\n}\nvoid inlinehook(void* target, void* hook_address) {\n    unsigned char jump_hook[10] = { 0 };\n    jump_hook[0] = 0xE9;\n    int offest = (int)hook_address - (int(target) + 5);\n    *(int*)&jump_hook[1] = offest;\n    DWORD oldprotect = 0;\n    VirtualProtect(target, 4096, PAGE_EXECUTE_READWRITE, &oldprotect);\n    memcpy(target, jump_hook, 5);\n    VirtualProtect(target, 4096, PAGE_EXECUTE_READWRITE, &oldprotect);\n}\nint main()\n{\n    inlinehook(MessageBoxA, hookMessageBox);\n    //void* targetFunction = (void*)MessageBoxA;\n    //void* p2 = (void*)hookMessageBox;\n    //printf(\"Address of MessageBoxA: %p\\n\", targetFunction);\n    //printf(\"Address of HookMessageBoxA %p\\n\", p2);\n    MessageBoxA(NULL, \"hello world!\", \"inline_hook\", MB_OK);\n    return 0;\n}\n```\n\n![](Inline-hook/1.png)\n\n**上面这种inline hook 方式 会 使得 target 处的函数不能正确执行 ，一般是使用下面这种 hook 方式**\n\n![](Inline-hook/3.png)\n\n#### InlineHook.h\n\n```C++\n#pragma once\n\n#include <Windows.h>\n\ntypedef unsigned char byte;\ntypedef signed char int8_t;\ntypedef unsigned char uint8_t;\ntypedef short int16_t;\ntypedef unsigned short uint16_t;\ntypedef int int32_t;\ntypedef unsigned int uint32_t;\ntypedef long long int64_t;\ntypedef unsigned long long uint64_t;\ntypedef uint32_t boolean_t;\n\ntypedef struct _HOOK_STUB\n{\n\tbyte jz[2];\n\tbyte jnz[2];\n\tbyte flag[4];\n\tbyte nop[5];\n\tbyte jmp_handler[5];\n\tbyte origin_code[15];\n\tbyte jmp_origin_fun[5];\n\tbyte flag2[4];\n}HOOK_STUB, *PHOOK_STUB;\n\n\nclass CInlineHook\n{\npublic:\n\tCInlineHook();\n\t~CInlineHook();\n\n\tbool InstallHook(const char* ModuleName, const char* ApiName, void* HandlerAddress);\n\tbool InstallHook(void* TargetAddress, void* HandlerAddress);\n\tbool UninstallHook();\n\n\tvoid* GetOriginFunction() {\n\t\treturn m_OriginFunction;\n\t}\n\t\n\nprotected:\n\t//\n\t// 获取汇编指令长度，用于HOOK\n\t//\n\tstatic int InstructLen(void* Address);\n\tstatic const uint8_t c_opinfo[256];\n\n\nprotected:\n\tvoid InitHookStub(PHOOK_STUB HookStub);\n\n\tPHOOK_STUB m_HookStub;\n\tvoid* m_OriginFunction;\n\tvoid* m_TargetAddress;\n\tint m_HookLen;\n};\n\n\n```\n\n#### InlineHook.cpp\n\n```C++\n#include \"InlineHook.h\"\n#include <stdio.h>\n\n/**\n* info structure:\n*\t0x26 means: 6 2 (high-low, low-high)\n*\n* Bit 0:\n*\t1 - has ModR/M\n*\t0 - no ModR/M byte\n* Bit 1~3:\n*\t0 - no imm\n*\t1 - Ib, Jb\n*\t2 - Iw\n*\t3 - Iv, Iz, Jz\n*\t4 - Ib + Iw\n*\n* special cases:\n*\t1. group f6xx, f7xx: nnn = 000,001 -- uses Iz\n*\t2. 9a, ea: Ap (xxxx:xxxxxxxx), 6-byte imm\n*\t3. Ob, Ov: 4-byte long offset\n*/\n\nconst uint8_t CInlineHook::c_opinfo[256] = {\n\t/*        0 1  2 3  4 5  6 7  8 9  A B  C D  E F  */\n\t/*       ---------------------------------------  */\n\t/* 00 */ 0x11, 0x11, 0x26, 0x00, 0x11, 0x11, 0x26, 0x00,\n\t/* 10 */ 0x11, 0x11, 0x26, 0x00, 0x11, 0x11, 0x26, 0x00,\n\t/* 20 */ 0x11, 0x11, 0x26, 0x00, 0x11, 0x11, 0x26, 0x00,\n\t/* 30 */ 0x11, 0x11, 0x26, 0x00, 0x11, 0x11, 0x26, 0x00,\n\t/* 40 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t/* 50 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t/* 60 */ 0x00, 0x11, 0x00, 0x00, 0x67, 0x23, 0x00, 0x00,\n\t/* 70 */ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,\n\t/* 80 */ 0x37, 0x33, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,\n\t/* 90 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t/* A0 */ 0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00,\n\t/* B0 */ 0x22, 0x22, 0x22, 0x22, 0x66, 0x66, 0x66, 0x66,\n\t/* C0 */ 0x33, 0x40, 0x11, 0x37, 0x80, 0x40, 0x02, 0x00,\n\t/* D0 */ 0x11, 0x11, 0x22, 0x00, 0x11, 0x11, 0x11, 0x11,\n\t/* E0 */ 0x22, 0x22, 0x22, 0x22, 0x66, 0x02, 0x00, 0x00,\n\t/* F0 */ 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11,\n\t/*        0 1  2 3  4 5  6 7  8 9  A B  C D  E F  */\n\t/*       ---------------------------------------  */\n\t0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, /* 0F 00 */\n\t0x11, 0x11, 0x11, 0x11, 0x10, 0x00, 0x00, 0x01, /* 0F 10 */\n\t0x11, 0x11, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, /* 0F 20 */\n\t0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, /* 0F 30 */\n\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, /* 0F 40 */\n\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, /* 0F 50 */\n\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, /* 0F 60 */\n\t0x33, 0x11, 0x11, 0x10, 0x00, 0x00, 0x11, 0x11, /* 0F 70 */\n\t0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, /* 0F 80 */\n\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, /* 0F 90 */\n\t0x00, 0x01, 0x31, 0x00, 0x00, 0x01, 0x31, 0x11, /* 0F A0 */\n\t0x11, 0x11, 0x11, 0x11, 0x00, 0x11, 0x11, 0x11, /* 0F B0 */\n\t0x11, 0x31, 0x33, 0x31, 0x00, 0x00, 0x00, 0x00, /* 0F C0 */\n\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, /* 0F D0 */\n\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, /* 0F E0 */\n\t0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10  /* 0F F0 */\n\t/*        0 1  2 3  4 5  6 7  8 9  A B  C D  E F  */\n\t/*       ---------------------------------------  */\n};\n\nenum cpu_mode_t { cm_legacy = -1, cm_compat = 0, cm_64bit = 1 };\n\nint CInlineHook::InstructLen(void* Address)\n{\n\tenum cpu_mode_t cm = cm_compat;\n\tregister uint8_t* p = (uint8_t*)Address;\n\tregister uint8_t b = 0;\n\tregister boolean_t pre_66 = false;\n\tuint8_t info;\n\tregister int tbl_fixup = 0;\n\tregister uint8_t i_info = 0;\n\tregister uint8_t modrm = 0;\n\n\tif (!Address)\n\t\treturn -1;\n\n\twhile (1)\n\t{\n\t\tb = *p++;\n\n\t\tif (b >= 0x40 && b <= 0x4f && cm == cm_64bit)\n\t\t\tcontinue;\n\t\telse if (b == 0x66) {\n\t\t\tpre_66 = true;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (b == 0xf0 || b == 0xf2 || b == 0xf3 ||\n\t\t\tb == 0x26 || b == 0x2e || b == 0x36 ||\n\t\t\tb == 0x3e || b == 0x64 || b == 0x65 ||\n\t\t\tb == 0x67)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\tif (b == 0x0f) {\n\t\tb = *p++;\n\t\ttbl_fixup = 128;\n\t}\n\n\tinfo = c_opinfo[(b >> 1) + tbl_fixup];\n\tinfo = ((b % 2) ? info : (info >> 4)) & 0x0f;\n\ti_info = (info >> 1) & 7;\n\n\tif (info & 0x01) {\n\t\t/* has modrm */\n\t\tmodrm = *p++;\n\t\tdo {\n\t\t\tregister uint8_t sib = 0;\n\t\t\tboolean_t has_sib = false;\n\t\t\tregister uint8_t tmp = 0;\n\n\t\t\tif ((modrm & 0xc0) == 0xc0)\t/* mod == 3 */\n\t\t\t\tbreak;\n\n\t\t\tif (cm != cm_legacy && (modrm & 0x07) == 4) {\n\t\t\t\thas_sib = true;\n\t\t\t\tsib = *p++;\n\t\t\t}\n\t\t\t/* displacement */\n\t\t\ttmp = has_sib ? sib : modrm;\n\t\t\tif (!(modrm & 0xc0)) {\t/* mod == 00b */\n\t\t\t\tif ((tmp & 0x07) == 5)\n\t\t\t\t\tp += (cm == cm_legacy) ? 2 : 4;\n\t\t\t}\n\t\t\telse if ((modrm & 0xc0) == 0x40) {\t/* mod == 01b */\n\t\t\t\t++p;\n\t\t\t}\n\t\t\telse {\t/* mod == 0x10b */\n\t\t\t\tp += (cm == cm_legacy) ? 2 : 4;\n\t\t\t}\n\t\t} while (0);\n\t}\n\n\t/* special cases */\n\tdo\n\t{\n\t\tregister uint8_t tmp = (modrm & 0x38) >> 3;\t/* nnn */\n\t\tif (tmp == 0 || tmp == 1) {\n\t\t\tif (b == 0xf6)\n\t\t\t\ti_info |= 1;\n\t\t\telse if (b == 0xf7)\n\t\t\t\ti_info |= 3;\t/* Iz */\n\t\t}\n\t\tif (b == 0x9a || b == 0xea)\t/* Ap */\n\t\t\tp += 6;\n\t\tif (b >= 0xa0 && b <= 0xa3)\n\t\t\tp += 4;\n\n\t} while (0);\n\n\t/* take care of immediate value */\n\tswitch (i_info) {\n\tcase 0:\tbreak;\n\tcase 1:\t++p; break;\n\tcase 2:\tp += 2;\tbreak;\n\tcase 3:\tp += pre_66 ? 2 : 4; break;\n\tcase 4:\tp += 3;\tbreak;\n\t}\n\n\treturn (int)(p - (uint8_t*)Address);\n}\n\n\n\nCInlineHook::CInlineHook()\n{\n\tm_HookStub = NULL;\n\tm_OriginFunction = NULL;\n\tm_TargetAddress = NULL;\n\tm_HookLen = 0;\n}\n\n\nCInlineHook::~CInlineHook()\n{\n\tif (m_HookStub)\n\t{\n\t\tdelete m_HookStub;\n\t\tm_HookStub = NULL;\n\t}\n}\n\nvoid CInlineHook::InitHookStub(PHOOK_STUB HookStub)\n{\n\tif (HookStub == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tZeroMemory(HookStub, sizeof(HOOK_STUB));\n\tHookStub->jz[0] = 0x74;\n\tHookStub->jz[1] = 0x06;\n\tHookStub->jnz[0] = 0x75;\n\tHookStub->jnz[1] = 0x04;\n\tmemcpy(HookStub->flag, \"xuan\", sizeof(HookStub->flag));\n\tmemset(HookStub->nop, 0x90, sizeof(HookStub->nop));\n\tHookStub->jmp_handler[0] = 0xE9;\n\tmemset(HookStub->origin_code, 0x90, sizeof(HookStub->origin_code));\n\tHookStub->jmp_origin_fun[0] = 0xE9;\n\tmemcpy(HookStub->flag2, \"yuan\", sizeof(HookStub->flag2));\n}\n\nbool CInlineHook::InstallHook(const char* ModuleName, const char* ApiName, void* HandlerAddress)\n{\n\tHMODULE hModule = NULL;\n\tvoid* targetAddress = NULL;\n\tbool bRet = false;\n\n\tdo \n\t{\n\t\thModule = GetModuleHandleA(ModuleName);\n\t\tif (!hModule)\n\t\t\tbreak;\n\n\t\ttargetAddress = GetProcAddress(hModule, ApiName);\n\t\tif (!targetAddress)\n\t\t\tbreak;\n\n\t\tbRet = InstallHook(targetAddress, HandlerAddress);\n\n\t} while (false);\n\n\treturn bRet;\n}\n\nbool CInlineHook::InstallHook(void* TargetAddress, void* HandlerAddress)\n{\n\tDWORD OldPageProperty = 0;\n\n\tif (TargetAddress == NULL || HandlerAddress == NULL || m_HookStub)\n\t{\n\t\treturn false;\n\t}\n\n\t//\n\t// 计算要HOOK的字节长度\n\t//\n\tint hook_len = 0;\n\tuint8_t* start_address = (uint8_t*)TargetAddress;\n\twhile (hook_len < 5)\n\t{\n\t\tint instruct_len = InstructLen(start_address);\n\t\tif (instruct_len <= 0 || instruct_len >= 10)\n\t\t\tbreak;\n\n\t\thook_len += instruct_len;\n\t\tstart_address += instruct_len;\n\t}\n\n\t//\n\t// 分配中间跳指令区，并设置可执行属性\n\t//\n\tm_HookStub = new HOOK_STUB();\n\tif (m_HookStub == NULL)\n\t{\n\t\treturn false;\n\t}\n\tif (!VirtualProtect(m_HookStub, sizeof(HOOK_STUB), PAGE_EXECUTE_READWRITE, &OldPageProperty))\n\t{\n\t\tdelete m_HookStub;\n\t\tm_HookStub = NULL;\n\t\treturn false;\n\t}\n\n\t//\n\t// 准备hook中间跳转指令\n\t//\n\tInitHookStub(m_HookStub);\n\tmemcpy(m_HookStub->origin_code, TargetAddress, hook_len);\n\t*((unsigned long *)(&m_HookStub->jmp_handler[1])) = (unsigned long)HandlerAddress - ((unsigned long)&m_HookStub->jmp_handler + 5);\n\t*((unsigned long *)(&m_HookStub->jmp_origin_fun[1])) = ((unsigned long)TargetAddress + hook_len) - ((unsigned long)&m_HookStub->jmp_origin_fun + 5);\n\n\n\t//\n\t// 准备Hook目标入口跳转指令\n\t//\n\tbyte jmp_entry[20] = { 0 };\n\tmemset(jmp_entry, 0x90, sizeof(jmp_entry));\n\tjmp_entry[0] = 0xE9;\n\t*((unsigned long*)(&jmp_entry[1])) = (unsigned long)m_HookStub - ((unsigned long)TargetAddress + 5);\n\n\t//\n\t// 开始安装钩子\n\t//\n\tOldPageProperty = 0;\n\tVirtualProtect(TargetAddress, hook_len, PAGE_READWRITE, &OldPageProperty);\n\tmemcpy(TargetAddress, jmp_entry, hook_len);\n\tVirtualProtect(TargetAddress, hook_len, OldPageProperty, &OldPageProperty);\n\n\tm_OriginFunction = &m_HookStub->origin_code;\n\tm_TargetAddress = TargetAddress;\n\tm_HookLen = hook_len;\n\treturn true;\n}\n\nbool CInlineHook::UninstallHook()\n{\n\tif (m_HookStub == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\tDWORD OldPageProperty = 0;\n\n\tVirtualProtect(m_TargetAddress, m_HookLen, PAGE_READWRITE, &OldPageProperty);\n\tmemcpy(m_TargetAddress, m_HookStub->origin_code, m_HookLen);\n\tVirtualProtect(m_TargetAddress, m_HookLen, OldPageProperty, &OldPageProperty);\n\n\tdelete m_HookStub;\n\tm_HookStub = NULL;\n\n\treturn true;\n\n}\n```\n\n#### Test.cpp\n\n```C++\n// Test.cpp : 定义控制台应用程序的入口点。\n//\n\n#include <Windows.h>\n#include \"InlineHook.h\"\n\n#include <map>\n#include <string>\nusing namespace std;\n\nmap<string, CInlineHook*> hookTable;\n\ntypedef int (WINAPI *PFN_MessageBoxA) (\n\t\t\t\t\t\t  __in_opt HWND hWnd,\n\t\t\t\t\t\t  __in_opt LPCSTR lpText,\n\t\t\t\t\t\t  __in_opt LPCSTR lpCaption,\n\t\t\t\t\t\t  __in UINT uType);\nint WINAPI HookMessageBoxA(\n\t\t\t\t__in_opt HWND hWnd,\n\t\t\t\t__in_opt LPCSTR lpText,\n\t\t\t\t__in_opt LPCSTR lpCaption,\n\t\t\t\t__in UINT uType)\n{\n\tprintf(\"%s: %s\\n\", lpText, lpCaption);\n\n\tCInlineHook* hook = hookTable[\"MessageBoxA\"];\n\n\tPFN_MessageBoxA pfn_MessageBoxA = (PFN_MessageBoxA)hook->GetOriginFunction();\n\n\tpfn_MessageBoxA(hWnd, lpText, lpCaption, uType);\n\n\treturn 0;\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n\n    CInlineHook hook;\n\t\n    hook.InstallHook(\"user32.dll\", \"MessageBoxA\", HookMessageBoxA);\n\thookTable.insert(pair<string, CInlineHook*>(\"MessageBoxA\", &hook));\n    \n\tMessageBoxA(NULL, \"this is my Blog!\", \"@Xhani\", MB_OK);\n\thookTable[\"MessageBoxA\"]->UninstallHook();\n\treturn 0;\n}\n```\n\n**此hook 方法不会 影响原函数的正确 执行**\n\n![](Inline-hook/4.png)\n\n###### *Todo1.编程实现HOOK WriteFile 这个Windows API，实现每次调用这个函数的时候，在写入的数据后面增加一个字符串:\"xhani!!!\"。然后程序里尝试打开一个文件，并写入一些数据，最后打开文件看看是否有这个字符串内容。*\n\n#### Todo1.cpp\n\n###### 1.方法一\n\n```C++\n// Todo1.cpp : 定义控制台应用程序的入口点。\n//\n#include <Windows.h>\n#include \"InlineHook.h\"\n#include<string.h>\n\n#include <map>\n#include <string>\nusing namespace std;\n\nmap<string, CInlineHook*> hookTable;\n\ntypedef\nBOOL\n(WINAPI* PFN_WriteFile)(\n\t_In_ HANDLE hFile,\n\t_In_reads_bytes_opt_(nNumberOfBytesToWrite) LPCVOID lpBuffer,\n\t_In_ DWORD nNumberOfBytesToWrite,\n\t_Out_opt_ LPDWORD lpNumberOfBytesWritten,\n\t_Inout_opt_ LPOVERLAPPED lpOverlapped);\n\nBOOL\nWINAPI\nHookWriteFile(\n\t_In_ HANDLE hFile,\n\t_In_reads_bytes_opt_(nNumberOfBytesToWrite) LPCVOID lpBuffer,\n\t_In_ DWORD nNumberOfBytesToWrite,\n\t_Out_opt_ LPDWORD lpNumberOfBytesWritten,\n\t_Inout_opt_ LPOVERLAPPED lpOverlapped\n)\n{\n\tCInlineHook* hook = hookTable[\"WriteFile\"];\n\n\tconst char  str[] = \"Xhani!!!\";\n\tsize_t len = strlen(str) + nNumberOfBytesToWrite;\n\tchar *newbuffer=(char *)malloc(len+1);\n\tif (newbuffer == NULL) return false;\n\tmemcpy(newbuffer,lpBuffer,nNumberOfBytesToWrite);\n\tmemcpy(newbuffer+nNumberOfBytesToWrite-1, str, strlen(str)+1);\n\tnNumberOfBytesToWrite += strlen(str);\n    \n\tPFN_WriteFile pfn_WriteFile = (PFN_WriteFile)hook->GetOriginFunction();\n\t\n\tpfn_WriteFile(hFile, newbuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);\n\treturn true;\n}\n\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n\tHANDLE hFile = CreateFile(\n\t\tL\"example.txt\",            // 文件名\n\t\tGENERIC_WRITE,           // 写入访问权限\n\t\t0,                       // 不共享\n\t\tNULL,                    // 默认安全性\n\t\tCREATE_ALWAYS,          // 如果文件存在则覆盖\n\t\tFILE_ATTRIBUTE_NORMAL,   // 普通文件\n\t\tNULL                     // 无模板文件\n\t);\n\tCInlineHook hook;\n\thook.InstallHook(\"kernel32.dll\", \"WriteFile\", HookWriteFile);\n\n\thookTable.insert(pair<string, CInlineHook*>(\"WriteFile\", &hook));\n\t\n\tchar buffer[]=\"1112211213\";\n\t//fgets(buffer, sizeof(buffer), stdin);\n\tDWORD bytesWritten;\n\n\tWriteFile(hFile, buffer,sizeof(buffer),&bytesWritten,NULL);\n\t\n\thookTable[\"WriteFile\"]->UninstallHook();\n\tCloseHandle(hFile);\n\treturn 0;\n}\n```\n\n###### 2.方法二\n\n```C++\n// 使用backup  拷贝修改处的指令\n#include<windows.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nvoid* Backup;\n#define BUFFER_SIZE  1024\n\nvoid inline_hook(void* target, void* hook_address, void* Backup);\nvoid uninstall_hook(void* target, void* backup);\n\nBOOL WINAPI hookWriteFile(\n     HANDLE hFile,\n    LPCVOID lpBuffer,\n     DWORD nNumberOfBytesToWrite,\n     LPDWORD lpNumberOfBytesWritten,\n     LPOVERLAPPED lpOverlapped\n)\n{\n    uninstall_hook(WriteFile,Backup);\n    \n    char str[] = \"Xhani!!!!!\";\n    size_t NewSize = strlen(str) + nNumberOfBytesToWrite;\n    char* buffer = (char*)malloc(NewSize+1);\n    if (buffer == NULL) return false;\n    memcpy(buffer,lpBuffer ,nNumberOfBytesToWrite);\n    memcpy(buffer + nNumberOfBytesToWrite, str,strlen(str)+1);\n    nNumberOfBytesToWrite += strlen(str);\n    \n    bool success = WriteFile(hFile, buffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);\n    \n    inline_hook(WriteFile,hookWriteFile,Backup);//  安装钩子，确保下次是调用到钩子\n    return success;\n}\nvoid inline_hook(void* target, void* hook_address,void *Backup)\n{\n    unsigned char jump_Code[10] = { 0 };\n    jump_Code[0] = 0xE9;\n    int offest = (int)hook_address - (int)target - 5;\n    *(int*)&jump_Code[1] = offest;\n    DWORD oldproperty = 0;\n    VirtualProtect(target, sizeof(jump_Code), PAGE_EXECUTE_READWRITE, &oldproperty);\n    memcpy(Backup, target, 5);\n    memcpy(target, jump_Code, 5);\n    VirtualProtect(target, sizeof(jump_Code), oldproperty, &oldproperty);\n    return;\n}\n\nvoid uninstall_hook(void* target, void* backup) {\n    DWORD oldproperty = 0;\n    VirtualProtect(target, 4096, PAGE_EXECUTE_READWRITE, &oldproperty);\n    memcpy(target, backup, 5);\n    VirtualProtect(target, 4096, oldproperty, &oldproperty);\n    return;\n}\nint main()\n{\n    HANDLE hFile = CreateFile(\n        L\"example.txt\",            // 文件名\n        GENERIC_WRITE,           // 写入访问权限\n        0,                       // 不共享\n        NULL,                    // 默认安全性\n        CREATE_ALWAYS,          // 如果文件存在则覆盖\n        FILE_ATTRIBUTE_NORMAL,   // 普通文件\n        NULL                     // 无模板文件\n    );\n    Backup = malloc(5);\n    if (hFile != INVALID_HANDLE_VALUE) {\n        DWORD bytesWritten; // 实际写入的字节数\n        char buffer[] = \"123456\";\n        inline_hook(WriteFile, hookWriteFile,Backup);\n        WriteFile(hFile, buffer, strlen(buffer), &bytesWritten, NULL);\n    }\n    CloseHandle(hFile);\n    free(Backup);\n    return 0;\n}\n```\n\n\n\n## 2.x64 位下的Inline hook\n\n#### 需要注意的是x64 下的 jmp 指令实际是 14个字节(<u>间接跳转</u>)  ：  jmp指令(FF 25)+ offest1(4字节)+0ffest2(8字节)  [因为64位下寻址更慢] \n\n> [!NOTE]\n>\n> **首先是计算出  jmp + offset1 的地址p1 ,然后寻址到p1处，在计算出p1+offest2 ,即为目标地址**\n\n\n\n```c++\n#include<stdio.h>\n#include<Windows.h>\nvoid sh() {\n    printf(\"true\");\n    return;\n}\nvoid sa()\n{\n    printf(\"false\");\n    return;\n}\nvoid inlinehook(__int64* target, __int64* hook_address) {\n    char jump_hook[14] = {0xFF,0x25,00,00,00,00,00,00,00,00,00,00,00,00 };\n    __int64* p = (_int64*)&hook_address;\n    memcpy(jump_hook + 6,p , sizeof(void*));\n \t//char jump_hook[] = {0xFF,0x25,0x01,00,00,00,00,00,00,00,00,00,00,00,00 };\n \t//__int64* p = (_int64*)&hook_address;\n \t//memcpy(jump_hook + 7,p , sizeof(void*));\n    DWORD oldprotect = 0;\n    VirtualProtect(target, sizeof(jump_hook), PAGE_EXECUTE_READWRITE, &oldprotect);\n    memcpy(target, jump_hook, sizeof(jump_hook));\n    VirtualProtect(target, sizeof(jump_hook), oldprotect, &oldprotect);\n    return;\n}\nint main()\n{\n    inlinehook((__int64 *)sa,(_int64 *)sh);\n    sa();\n    return 0;\n}\n```\n\n![](Inline-hook/2.png)\n\n\n\n","tags":["hook"]},{"title":"常见汇编","url":"/2024/09/14/deassembly-md/","content":"\n# if_else:\n\n```\n\t\tcmp a,b\n\t\tje 0x0001\n\t\t操作2 Yes\n\t\tjmp 0x0002\n0x0001:\t操作3 NO\n0x0002:\n```\n\n![](deassembly-md/image-20240914194223239.png)\n\n# switch case:\n\n```\n\t\t操作1\n\t\tcmp  a,400\n\t\tjg 0x000000\n\t\tcmp a,400\n\t\tje 0x000001\n\t\tcmp a,300\n\t\tje 0x00002\n\t\tcmp a,200\n\t\tje 0x0003\n\t\tjmp 0x0004           \n\t\t操作2  \n\t\tjmp 0x0004         //实际上是有break;\n\t\t操作3\n\t\tjmp 0x0004 \n\t\t操作4\n\t\tjmp 0x0004\n\t\t操作5\n0x0004:\n```\n\n![](deassembly-md/image-20240914194329734.png)\n\n# while()\n\n```\n0x0000: cmp a,100\n      \tjle 0x00001\n\t\t操作\n\t\tjmp 0x0000\n0x00001:\n```\n\n![](deassembly-md/image-20240914195237570.png)\n\n# do  while()\n\n```\n0x00001:操作\n\t\tcmp a,100\n\t\tjle  0x00001\n```\n\n![](deassembly-md/image-20240914195647559.png)\n\n# for()\n\n```\n\t\tmov dowrd ptr[ebp-8],1\n\t\tjmp 0x00001\n0x00003:操作\n       \tadd/sub/mul/div ecx,dowrd ptr[ebp-8]\n0x00001:cmp ecx,dowrd ptr[ebp-8]\n\t\tjg 0x00002\n\t\t操作\n\t\tjmp 0x00003\n0x00002:\n```\n\n![](deassembly-md/image-20240914195836157.png)\n","tags":["汇编"]},{"title":"网络空间搜索引擎2","url":"/2024/05/23/网络空间搜索引擎2/","content":"\n# shodan\n\n使用文档：https://xz.aliyun.com/t/2070?time__1311=n4%2BxnieDqmqqB7DuDBTroGkYDkQG8Y%2FRB%2F%2BeD&alichlgref=https%3A%2F%2Fwww.google.com%2F\n\nshodan的查询快捷语句：https://github.com/jakejarvis/awesome-shodan-queries\n\nshodan的py脚本：https://github.com/random-robbie/My-Shodan-Scripts\n\n## 1.shodan.io\n\n**shodan搜索使用文档：https://help.shodan.io/the-basics/search-query-fundamentals**\n\nkali上内置shodan\n\n## 2.shodan的功能：\n\n- 地图\n- 监控\n- 截图\n- 过滤器\n\n## 3.shodan常见命令：\n\n```\nshodan host 172.67.167.88\n```\n\n```\nshodan count apache\n```\n\n```\nshodan stats port:445 SMB\n```\n\n","tags":["web"]},{"title":"网络空间搜索引擎1","url":"/2024/05/23/网络空间搜索引擎1/","content":"\n## 1.什么是网络空间：Cyber space\n\n搜索引擎：goole诞生————网页\n\n发展：图片 音乐 声音\n\n进一步：\n\n| 网络系统 | 网络设备                 | 工业系统                 |\n| -------- | ------------------------ | ------------------------ |\n| CDN      | 手机                     | 交通信号灯  公园控制系统 |\n| IDS      | 平板                     | 核电站                   |\n| CMS      | 交换机 路由器 网络摄像头 | 加油站                   |\n| 办公软件 | 私人网盘                 | 电网                     |\n| 数据库   | 打印机  ATM 机器人       | 企业大屏幕               |\n\n## 2.网络空间搜索引擎：\n\n##### 怎么扫描：1.用网络工具：zmap nmap  2.方式：IP库 枚举\n\n怎么标识设备：\n\n- ip:域名\n\n- MAC\t\n\n- 爬虫：url\n\n- 开放系统\n- 物理地址\n- 操作系统\n- 设备类型\n\n## 3.实行威胁地图：fireeye\n\n## 4.安全性\n","tags":["web"]},{"title":"Google_hacking","url":"/2024/05/23/Google-hacking/","content":"\n## 1.语法工具：pdf文档：https://web.archive.org/web/20140822191407/http://www.boris-koch.de/wp-content/uploads/2011/01/Liste-Google-Hacking.pdf\n\n\n\n## 2.一些运算符：\n\n**完全匹配:**\n\n```\n\"网络安全\"\n```\n\n**任意词语：**\n\n```\n1 or 2\n```\n\n**不包含：**\n\n```\nburp_suite - xxx\n```\n\n**数字范围：**\n\n```\nnumber..number\n```\n\n## 3.高级语法\n\n**1.只搜索某个网站的内容：**\n\n```\nsite:zhihu.com\n```\n\n**2.网页内容包括：**\n\n```\nallintext:Powered by Discuz\nintext：Powered by Discuz\n```\n\n###### 标题：是html网页标签的标题\n\n **3.标题出现：**\n\n```\nintitle：\nallintitle:\n```\n\n**4.url地址包括：**\n\n```\nallinurl:admin.php\ninurl:index.php?id=1\n```\n\n**5.文件类型：**\n\n```\nfiletype：pdf\n```\n\n**6.index of**\n\n```\nintitle:index of\n```\n\n##  4.google语法数据库：\n\nhttps://www.exploit-db.com/google-hacking-database\n\nhttps://github.com/BullsEye0/google_dork_list\n\n## 5.工具：\n\ngithub搜索：Google hcaking \n\n​\t\t\tGoogle dorks \n"},{"title":"WAF_difference","url":"/2024/05/16/WAF_difference/","content":"\n# WAF:web应用防火墙\n\n### 1.作用（简单的）\n\n![image1](WAF_difference/1.png)\n\n### 2.WAF识别思路：\n\n1.[0xInfection/Awesome-WAF: 🔥 Web-application firewalls (WAFs) from security standpoint. (github.com)](https://github.com/0xInfection/Awesome-WAF)\n\n2.[CSecGroup/wafid: Wafid identify and fingerprint Web Application Firewall (WAF) products. (github.com)](https://github.com/CSecGroup/wafid)\n\n### 3.如何触发waf拦截：\n\n##### 1.工具：kali:wafw00f\n\n```\nwafw00f https://pinpai.smzdm.com/\n```\n\n```\nnmap www.12306.cn --script=http-waf-detect.nse\n```\n\n**必须是动态地址**：\n\n```\nsqlmap -u \"xxx.com?id=1\" --identify-waf\n```\n\n","tags":["web"]},{"title":"CDN_difference","url":"/2024/05/16/CDN-difference/","content":"\n### 1.CDN是什么：[CDN图解（秒懂 + 史上最全） - 疯狂创客圈 - 博客园 (cnblogs.com)](https://www.cnblogs.com/crazymakercircle/p/14978513.html)\n\n### 2.如何获取CDN背后的真实ip\n\n1.ping\n\n2.\n\n```\nnslookup 域名\n```\n\n3.超级ping\n\n4.Kali工具:lbd\n\n5.国内：cdn.chinaz.com\n\n国外cdnplanet.com/tools/cdnfinder\n\n6.脚本：\n\nhttps://github.com/boy-hack/w8fuckcdn/\n\nhttps://gitghub.com/3xp10it/xcdn\n","tags":["web"]},{"title":"CMS_judgement","url":"/2024/05/15/CMS-judgement/","content":"\n# CMS的指纹识别\n\n## 1.识别对象：\n\n#### 1.**CMS信息**：内容管理系统\n\n2.前端技术：\n\n3.开发语言\n\n4.web服务器\n\n5.应用服务器\n\n6.操作系统\n\n#### 7.CDN的信息\n\n#### 8.WAF信息\n\n## 2.CMS：\n\n各类开源的CMS：企业，博客，论坛，问答，知识百科，门户建站，在线教育建站，人才招聘网站\n\n## 3.CMS识别思路：\n\n###### 1.版权信息\n\n###### 2.特定文件MD5值:(https://github.com/Lucifer1993/cmsprint/blob/master/cmsprint.json)\n\n###### 3.查看页面原代码:分析代码\n\n###### 4.查看特定文件分析：如网站的robots .txt文件\n\n## 4.CMS工具：\n\n###### 1.kali工具：whatweb\n\n```kali\n`whatweb  -v www.coolshell.cn`\n```\n\n\n\n###### 2.浏览器插件：Wappalyzer,whatruns\n\n###### 3.https://github.com/Tuhinshubhra/CMSeek\n\n###### 4.http://finger.tidesec.com/\n\n","tags":["web"]},{"title":"namp的使用","url":"/2024/05/14/Use_nmap/","content":"\n# 1.nmap的使用：[](https://blog.csdn.net/weixin_49998039/article/details/125242779)\n\n### 1.类别：\n\nopen:端口开启\n\nfiltered:被防火墙阻止扫描\n\nclosed：端口关闭\n\nunfiltered：无法确定的\n\n### 2.nmap的参数\n\nnmap -sV:版本检测\n\n-PN:绕过ping命令\n\n-O：操作系统检测，1-6\n\n-T：设置扫描速度\n\n-sP：主机存活性\n\n-Ss:SYN方式\n\n-ST:三次握手\n\n-SP:没有扫描\n\n-pn:🈲ping\n\n-Su:udp的数据包\n\n-sF:FIN的方式\n\n### 3.范围内：\n\n192.168.1.1-4\n\n### 4.注意其他工具的结合：masscan:[](https://blog.csdn.net/2302_82189125/article/details/135999466)\n\nfofa.info，fofa-view插件\n\n### 5.常见端口\n\nThis is a img\n\n![image](Use_nmap/1.png)\n","tags":["web"]},{"title":"端口信息","url":"/2024/05/10/端口信息/","content":"\n## 1.端口扫描和代码实现：\n\n1.`windows :netstat -aon|findstr 3306`\n\n`linux:netstat -an|grep 3306`\n\n2.对端口发数据包扫：\n\n命令：`wget ip 80`\n\n`telnet ip 80`\n\n`nc -vz ip 445`\n\n3.工具\n\n扫描主机，端口，探测操作系统，软件版本**zenmap**\n\nnmap 使用文档 \n\n**dirsearch脚本**\n\n**masscan**\n\n\n\n4.端口类型：\n\n文件共享：\n\n远程连接：\n\nweb应用：\n\n数据库服务\n\n网路常见端口\n\n特殊服务端口\n\n","tags":["web"]},{"title":"ip信息收集","url":"/2024/05/10/ip信息收集/","content":"\n# ip信息收集：\n\n## 1.DNS类型\n\n##### 1.本地域名服务器，根域名服务器，顶级域名，授权域名\n\n##### 2.迭代查询，递归查询\n\n## 2.ping/nslookup\n\n##### ping:应用层 \n\n命令：`nslookup -type=\"MS\" baidu.com`\n\n## 3.IP归属：\n\n1.ipwhois.cnnic.cn\n\n2.ip138.com\n\n## 4.CDN服务：\n\n#### 要找到CDN背后的真实ip\n\n###### 1.超级ping\n\n######  2.历史DNS:dnshistory  \n\n###### 3.通过子域名\n\n###### 4.国外主机解析:dnscheck,webpagetest.org\n\n###### 5.邮件，SSL证书，手机抓包\n\n\n\n\n\n","tags":["web"]},{"title":"域名信息收集","url":"/2023/11/17/域名信息/","content":"\n#   1.域名信息\n\n## 1.分类：\n\n国际域名：com,net,org,gov,edu,mil,int\n\n国别：cn,uk,us,\n\n新顶级域名：biz,name,pro,info,coop,museum\n\n## 2.域名联系人信息:姓名，邮箱，手机号\n\n### 1.域名查询\n\n#### 1.阿里云\n\n#### 2.whois.chinaz.com\n\n#### 3.whoissoft.com\n\n#### 4.whois.cnnic.cn\n\n#### 5.kail命令\n\n```ABAP\nwhois 域名\n```\n\n### 2.域名反差：\n\n#### 1.whois.chinaz.com\n\n### 3.备案信息\n\n#### 1.beian.miit.gov.cn\n\n#### 2.beian88.com\n\n#### 3.天眼查\n\n### 3.子域名：\n\n#### 1.例如：news.baidu.com\n\n**工具：1.Layer   2. subDomainsBrute**\n\n**字典拆解，枚举**\n\n### DNS服务：\n\nDNS服务器\n1.主机记录\n\n记录类型：A:指定ip地址，CNAME：将一个域名指向另一个域名，AAAA，MX，TXT，NS：域名服务器记录\n\n2.查询：\n\n[域名解析查询(A/Txt/Cname/Mx/Srv/Aaaa...) (dbcha.cn)](http://dbcha.cn/)\n\nnetcraft\n\njsons.cn\n\nkail工具：maltego\n\n","tags":["web"]}]